"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_spotlightjs_overlay_dist_index-BfFEknL3_js"],{

/***/ "(app-pages-browser)/./node_modules/@spotlightjs/overlay/dist/index-BfFEknL3.js":
/*!******************************************************************!*\
  !*** ./node_modules/@spotlightjs/overlay/dist/index-BfFEknL3.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONSTANT_BOLD_FONT: () => (/* binding */ ct),\n/* harmony export */   CONSTANT_NORMAL_FONT: () => (/* binding */ V),\n/* harmony export */   DEFAULT_GRAPH_OPTIONS: () => (/* binding */ _),\n/* harmony export */   DEFAULT_PALETTE: () => (/* binding */ xt),\n/* harmony export */   Flamegraph: () => (/* binding */ Ot),\n/* harmony export */   GraphBase: () => (/* binding */ q),\n/* harmony export */   Sunburst: () => (/* binding */ At),\n/* harmony export */   Treemap: () => (/* binding */ zt),\n/* harmony export */   colorToCanvasFill: () => (/* binding */ $),\n/* harmony export */   createColorGetterFromMap: () => (/* binding */ ft),\n/* harmony export */   createColorGetterSpectrum: () => (/* binding */ pt),\n/* harmony export */   getTreeMaxDepth: () => (/* binding */ at),\n/* harmony export */   hueAngleToColor: () => (/* binding */ mt),\n/* harmony export */   normalizeTreeNode: () => (/* binding */ wt)\n/* harmony export */ });\nvar dt = Object.defineProperty;\nvar ut = (n, o, t) => o in n ? dt(n, o, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[o] = t;\nvar l = (n, o, t) => ut(n, typeof o != \"symbol\" ? o + \"\" : o, t);\nfunction mt(n, o = 1, t = 1) {\n  const e = (0.6 + 0.4 * Math.max(0, Math.cos(n))) * o, i = (0.5 + 0.2 * Math.max(0, Math.cos(n + Math.PI * 2 / 3))) * t;\n  return `hsl(${n * 180 / Math.PI}deg, ${Math.round(100 * e)}%, ${Math.round(100 * i)}%)`;\n}\nlet J, tt, et, W, S, y = 1, E;\nfunction $(n, o, t, e, i) {\n  if (!Array.isArray(n))\n    return n;\n  const s = window.devicePixelRatio || 1;\n  if (J !== o || tt !== s || et !== i) {\n    const h = Math.round(64 * s) / 64;\n    y = i, y = Math.log2(y), y -= Math.floor(y);\n    const a = y, r = Math.min(1, 8 * a);\n    y = 2 ** y;\n    const c = 8 * Math.SQRT2 / y;\n    J = o, tt = s, et = i, W || (W = document.createElement(\"canvas\")), S || (S = W.getContext(\"2d\")), W.width = W.height = Math.round(64 * h), S.scale(h, h), S.fillStyle = n[0], S.fillRect(0, 0, 64, 64), S.globalAlpha = 0.25, S.fillStyle = n[1], S.fillRect(0, 0, 64, 64), S.globalAlpha = 0.67, S.strokeStyle = n[1], S.beginPath();\n    for (let d = 0; d <= 64; d += 16)\n      S.moveTo(d - 32, d + 32), S.lineTo(d + 32, d - 32);\n    if (S.lineWidth = c * (1 - (r - a) / 2), S.stroke(), r + a > 0) {\n      S.beginPath();\n      for (let d = 8; d < 64; d += 16)\n        S.moveTo(d - 32, d + 32), S.lineTo(d + 32, d - 32);\n      S.lineWidth = c * (r + a) / 2, S.stroke();\n    }\n    E = o.createPattern(W, \"repeat\"), y /= h;\n  }\n  return t /= 64 * y * s, t -= Math.floor(t), t *= 64 * y * s, E.setTransform(new DOMMatrix([\n    y,\n    0,\n    0,\n    y,\n    t,\n    e\n  ])), E;\n}\nfunction ft(n) {\n  return (o) => o.id && n[o.id] || o.color;\n}\nfunction pt(n, o = 1, t = 1) {\n  const e = {};\n  return ot(e, n, 0, Math.PI * 2, o, t), ft(e);\n}\nfunction ot(n, o, t, e, i = 1, s = 1) {\n  const h = o.size;\n  n[o.id] = mt(t + e / 2, i, s);\n  for (const a of o.children) {\n    const r = a.size / h * e;\n    ot(n, a, t, r, i, s), t += r;\n  }\n}\nconst vt = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction gt(n = 16, o = vt) {\n  let t = \"\", e = n;\n  const i = o.length;\n  for (; e--; )\n    t += o[Math.random() * i | 0];\n  return t;\n}\nfunction wt(n, o, t = (e, i) => i.size - e.size) {\n  if (n.__nanovis)\n    return n;\n  const e = {\n    ...n\n  };\n  return e.id || (e.id = gt()), e.parent || (e.parent = o), e.children || (e.children = []), e.sizeSelf == null && e.size != null && e.children.length === 0 ? e.sizeSelf = e.size : e.sizeSelf || (e.sizeSelf = 0), e.children = (e.children || []).map((i) => wt(i, e, t)), e.size || (e.size = e.children.reduce((i, s) => i + s.size, 0) + e.sizeSelf), t && e.children.sort(t), Object.defineProperty(e, \"__nanovis\", { enumerable: !1, value: !0 }), e;\n}\nfunction at(n) {\n  return n.children.length === 0 ? 1 : Math.max(...n.children.map((o) => at(o))) + 1;\n}\nconst Nt = /\\bFirefox\\//.test(navigator.userAgent);\nlet X;\nfunction rt(n) {\n  return X ? X.format(n) : `${n}`;\n}\nfunction D() {\n  return (window.performance || Date).now();\n}\nfunction H(n) {\n  const o = n.toFixed(1).split(\".\", 2);\n  return `${rt(+o[0])}.${o[1]}`;\n}\nfunction St(n) {\n  return n === 1 ? \"1 byte\" : n < 1024 ? `${rt(n)} bytes` : n < 1024 * 1024 ? `${H(n / 1024)} kb` : n < 1024 * 1024 * 1024 ? `${H(n / (1024 * 1024))} mb` : `${H(n / (1024 * 1024 * 1024))} gb`;\n}\nfunction lt(n, o, t, e, i, s) {\n  if (Nt) {\n    const h = n.lineWidth, a = h / 2;\n    n.fillStyle = o, n.fillRect(t - a, e - a, i + h, h), n.fillRect(t - a, e + a, h, s - h), n.fillRect(t - a, e + s - a, i + h, h), n.fillRect(t + i - a, e + a, h, s - h);\n    return;\n  }\n  n.strokeStyle = o, n.strokeRect(t, e, i, s);\n}\nfunction G(n) {\n  return window.addEventListener(\"wheel\", n, { passive: !1 }), () => window.removeEventListener(\"wheel\", n);\n}\nfunction j(n) {\n  return window.addEventListener(\"resize\", n), () => window.removeEventListener(\"resize\", n);\n}\ntry {\n  X = new Intl.NumberFormat();\n} catch {\n}\nlet Mt = () => ({\n  emit(n, ...o) {\n    for (let t = this.events[n] || [], e = 0, i = t.length; e < i; e++)\n      t[e](...o);\n  },\n  events: {},\n  on(n, o) {\n    var t;\n    return ((t = this.events)[n] || (t[n] = [])).push(o), () => {\n      var e;\n      this.events[n] = (e = this.events[n]) == null ? void 0 : e.filter((i) => o !== i);\n    };\n  }\n});\nconst _ = {\n  getText: (n) => n.text,\n  getSubtext: (n) => n.subtext,\n  animate: !0,\n  animateDuration: 350\n}, xt = {\n  fallback: \"#CCC\",\n  stroke: \"#0008\",\n  text: \"#222\",\n  hover: \"#fff5\",\n  shadow: \"#0008\",\n  fg: \"#fff\",\n  bg: \"#222\"\n}, yt = 46, V = \"14px sans-serif\", ct = `bold ${V}`;\nclass q {\n  constructor(o, t) {\n    l(this, \"el\");\n    l(this, \"canvas\");\n    l(this, \"c\");\n    l(this, \"width\", 0);\n    l(this, \"height\", 0);\n    l(this, \"ratio\", 1);\n    l(this, \"root\");\n    l(this, \"maxDepth\");\n    l(this, \"events\");\n    l(this, \"options\");\n    l(this, \"palette\");\n    l(this, \"disposables\");\n    l(this, \"getColor\");\n    l(this, \"getText\");\n    l(this, \"getSubtext\");\n    l(this, \"_animationFrame\", null);\n    l(this, \"_font\", \"14px sans-serif\");\n    l(this, \"_fontWidthCache\", /* @__PURE__ */ new Map());\n    l(this, \"ellipsisWidth\", 0);\n    this.options = {\n      ..._,\n      ...t\n    };\n    const {\n      getColor: e = pt(o),\n      getText: i = () => {\n      },\n      getSubtext: s = () => {\n      }\n    } = this.options;\n    this.palette = {\n      ...xt,\n      ...t.palette\n    }, this.el = document.createElement(\"div\"), this.canvas = document.createElement(\"canvas\"), this.c = this.canvas.getContext(\"2d\"), this.root = o, this.maxDepth = at(o), this.disposables = [], this.events = Mt(), this.getColor = e, this.getText = i, this.getSubtext = s, this.setFont(V), t.onClick && this.events.on(\"click\", t.onClick), t.onHover && this.events.on(\"hover\", t.onHover), t.onLeave && this.events.on(\"leave\", t.onLeave), t.onSelect && this.events.on(\"select\", t.onSelect), this.el.addEventListener(\"mouseleave\", () => {\n      this.events.emit(\"leave\");\n    });\n  }\n  /**\n   * Invalidate the graph and request a new frame.\n   */\n  invalidate() {\n    this._animationFrame === null && (this._animationFrame = requestAnimationFrame(() => {\n      this._animationFrame = null, this.tick();\n    }));\n  }\n  /**\n   * To be overridden by subclasses to implement custom animation logic.\n   */\n  tick() {\n    this.draw();\n  }\n  /**\n   * To be overridden by subclasses to implement custom animation logic.\n   */\n  draw() {\n  }\n  resize() {\n    this.ratio = window.devicePixelRatio || 1, this.canvas.style.width = `${this.width}px`, this.canvas.style.height = `${this.height}px`, this.canvas.width = Math.round(this.width * this.ratio), this.canvas.height = Math.round(this.height * this.ratio), this.c.scale(this.ratio, this.ratio), this.draw();\n  }\n  /**\n   * Select a node. To be overridden by subclasses to implement custom selection logic.\n   *\n   * @param node - The node to select.\n   * @param _animate - Whether to animate the selection.\n   */\n  select(o, t) {\n    this.events.emit(\"select\", o);\n  }\n  dispose() {\n    this.disposables.forEach((o) => o()), this.disposables.length = 0, this.el.remove();\n  }\n  [Symbol.dispose]() {\n    this.dispose();\n  }\n  getFontCache() {\n    return this._fontWidthCache.has(this._font) || this._fontWidthCache.set(this._font, {}), this._fontWidthCache.get(this._font);\n  }\n  setFont(o) {\n    this._font = o, this.c.font = o, this.c.textBaseline = \"middle\", this.ellipsisWidth = 3 * this.charCodeWidth(yt);\n  }\n  charCodeWidth(o) {\n    const t = this.getFontCache();\n    let e = t[o];\n    return e === void 0 && (e = this.c.measureText(String.fromCharCode(o)).width, t[o] = e), e;\n  }\n  textOverflowEllipsis(o, t) {\n    if (t < this.ellipsisWidth)\n      return [\"\", 0];\n    let e = 0;\n    const i = o.length;\n    let s = 0;\n    for (; s < i; ) {\n      const h = this.charCodeWidth(o.charCodeAt(s));\n      if (t < e + this.ellipsisWidth + h)\n        return [`${o.slice(0, s)}...`, e + this.ellipsisWidth];\n      e += h, s++;\n    }\n    return [o, e];\n  }\n}\nconst b = 24, Tt = 5, it = 0.01, st = 1e3;\nclass Ot extends q {\n  constructor(t, e = {}) {\n    super(t, e);\n    l(this, \"mainEl\", document.createElement(\"div\"));\n    l(this, \"totalBytes\");\n    l(this, \"viewportMin\");\n    l(this, \"viewportMax\");\n    l(this, \"zoomedOutMin\", 0);\n    l(this, \"zoomedOutWidth\", 0);\n    l(this, \"prevWheelTime\", 0);\n    l(this, \"prevWheelWasZoom\", !1);\n    l(this, \"stripeScaleAdjust\", 1);\n    l(this, \"hoveredNode\", null);\n    l(this, \"selectedNode\", null);\n    l(this, \"nodeStartBytes\", /* @__PURE__ */ new Map());\n    l(this, \"animationFromMin\", 0);\n    l(this, \"animationFromMax\", 0);\n    l(this, \"animationToMin\", 0);\n    l(this, \"animationToMax\", 0);\n    l(this, \"animationStart\", 0);\n    this.totalBytes = t.size, this.viewportMin = this.animationFromMin = this.animationToMin = 0, this.viewportMax = this.animationFromMax = this.animationToMax = this.totalBytes, Object.assign(this.mainEl.style, {\n      position: \"relative\"\n    }), Object.assign(this.canvas.style, {\n      position: \"absolute\",\n      left: \"0\",\n      top: \"0\"\n    });\n    let i = !1;\n    this.canvas.onmousedown = (s) => {\n      if (i = !1, s.button !== 2) {\n        let h = s.pageX;\n        const a = (c) => {\n          const d = c.pageX - h;\n          !i && Math.abs(d) < 3 || (i = !0, this.modifyViewport(-d, 0, null), h = c.pageX);\n        }, r = () => {\n          document.removeEventListener(\"mousemove\", a), document.removeEventListener(\"mouseup\", r);\n        };\n        s.preventDefault(), document.addEventListener(\"mousemove\", a), document.addEventListener(\"mouseup\", r);\n      }\n    }, this.canvas.onmousemove = (s) => {\n      this.updateHover(s);\n    }, this.canvas.onmouseout = () => {\n      this.changeHoveredNode(null);\n    }, this.canvas.onclick = (s) => {\n      if (i)\n        return;\n      const h = this.hitTestNode(s);\n      this.changeHoveredNode(h), this.changeSelectedNode(h), h && this.events.emit(\"click\", h, s);\n    }, this.disposables.push(G((s) => {\n      const h = s.deltaX, a = s.deltaY, r = D(), c = r - this.prevWheelTime < 50 ? this.prevWheelWasZoom : s.ctrlKey || s.metaKey;\n      this.prevWheelTime = r, this.prevWheelWasZoom = c, (c || Math.abs(h) >= Math.abs(a)) && s.preventDefault(), this.modifyViewport(h, a, c ? s.pageX : null), this.updateHover(s);\n    })), this.resize(), Promise.resolve().then(() => this.resize()), this.disposables.push(j(() => this.resize())), this.mainEl.append(this.canvas), this.el.append(this.mainEl);\n  }\n  tick() {\n    let t = (D() - this.animationStart) / (this.options.animateDuration ?? _.animateDuration);\n    t < 0 || t > 1 ? (t = 1, this.viewportMin = this.animationToMin, this.viewportMax = this.animationToMax) : (t < 0.5 ? t *= 4 * t * t : (t = 1 - t, t *= 4 * t * t, t = 1 - t), this.viewportMin = this.animationFromMin + (this.animationToMin - this.animationFromMin) * t, this.viewportMax = this.animationFromMax + (this.animationToMax - this.animationFromMax) * t, this.invalidate()), this.draw();\n  }\n  draw() {\n    this.c.clearRect(0, 0, this.width, this.height), this.drawNode(\n      this.root,\n      0,\n      0,\n      -1 / 0,\n      1\n      /* ROOT */\n    );\n  }\n  changeSelectedNode(t, e = this.options.animate ?? _.animate) {\n    if (this.selectedNode !== t && (this.selectedNode = t, this.events.emit(\"select\", t), t && this.nodeStartBytes.has(t.id))) {\n      let i = this.nodeStartBytes.get(t.id), s = i + t.size;\n      i = Math.max(0, i - t.size * it), s = Math.min(this.totalBytes, s + t.size * it), this.setViewport(i, s, e);\n    }\n  }\n  select(t, e = this.options.animate ?? _.animate) {\n    this.changeSelectedNode(t, e);\n  }\n  resize() {\n    this.width = this.el.clientWidth, this.height = this.maxDepth * b + 1, this.zoomedOutMin = this.width - st >> 1, this.zoomedOutWidth = this.zoomedOutMin + st, this.zoomedOutMin < 0 && (this.zoomedOutMin = 0), this.zoomedOutWidth > this.width && (this.zoomedOutWidth = this.width), this.zoomedOutWidth -= this.zoomedOutMin, this.stripeScaleAdjust = this.totalBytes / this.zoomedOutWidth, this.mainEl.style.height = `${this.height}px`, super.resize();\n  }\n  // We want to avoid overlapping strokes from lots of really small adjacent\n  // rectangles all merging together into a solid color. So we enforce a\n  // minimum rectangle width of 2px and we also skip drawing rectangles that\n  // have a right edge less than 1.5px from the previous right edge.\n  drawNode(t, e, i, s, h) {\n    this.nodeStartBytes.set(t.id, i);\n    const a = this.zoomedOutWidth / (this.viewportMax - this.viewportMin), r = this.zoomedOutMin + (i - this.viewportMin) * a, c = t.size * a, d = r + c;\n    if (d < s + 1.5)\n      return s;\n    if (r + c < 0 || r > this.width)\n      return d;\n    const m = c < 2 ? 2 : c, u = (r > 0 ? r : 0) + Tt, p = e + b / 2;\n    let v = this.getText(t) || \"\", g = this.getSubtext(t) || \"\", w, f = 0;\n    const N = c + r - u, M = $(this.getColor(t) || this.palette.fallback, this.c, this.zoomedOutMin - this.viewportMin * a, b, a * this.stripeScaleAdjust);\n    let T = this.palette.text, x = -1 / 0;\n    h & 1 ? (T = this.palette.fg, this.setFont(ct)) : (this.c.fillStyle = M, this.c.fillRect(r, e, m, b), (h & 2 || this.hoveredNode && t.id === this.hoveredNode.id) && (this.c.fillStyle = this.palette.hover, this.c.fillRect(r, e, m, b), h |= 2)), this.ellipsisWidth < N && (w = this.c.measureText(v).width, w <= N ? f += w : (v = this.textOverflowEllipsis(v, N)[0], f = N), this.c.fillStyle = T, this.c.fillText(v, u, p)), h & 1 && this.setFont(V), f + this.ellipsisWidth < N && (g && v && (g = ` - ${g}`), w = this.c.measureText(g).width, f + w > N && (g = this.textOverflowEllipsis(g, N - f)[0]), this.c.globalAlpha = 0.5, this.c.fillText(g, u + f, p), this.c.globalAlpha = 1);\n    for (const O of t.children)\n      x = this.drawNode(\n        O,\n        e + b,\n        i,\n        x,\n        h & -2\n        /* ROOT */\n      ), i += O.size;\n    return h & 1 || lt(this.c, this.palette.stroke, r + 0.5, e + 0.5, m, b), d;\n  }\n  changeHoveredNode(t) {\n    this.hoveredNode !== t && (this.hoveredNode = t, this.canvas.style.cursor = t && !t.children.length ? \"pointer\" : \"auto\", this.invalidate());\n  }\n  hitTestNode(t) {\n    const e = this.canvas.getBoundingClientRect(), i = t.clientX - e.left, s = t.clientY - e.top, h = this.viewportMin + (this.viewportMax - this.viewportMin) / this.zoomedOutWidth * (i - this.zoomedOutMin), a = (r, c, d) => {\n      if (h >= d && h < d + r.size) {\n        if (s >= c && s < c + b && r.id)\n          return r;\n        if (s >= c + b)\n          for (const m of r.children) {\n            const u = a(m, c + b, d);\n            if (u)\n              return u;\n            d += m.size;\n          }\n      }\n      return null;\n    };\n    return a(this.root, 0, 0);\n  }\n  modifyViewport(t, e, i) {\n    let s = this.viewportMin, h = this.viewportMax, a = 0;\n    if (i !== null) {\n      const r = s + (h - s) / this.zoomedOutWidth * (i - this.zoomedOutMin), c = 1.01 ** e;\n      s = r + (s - r) * c, h = r + (h - r) * c;\n    } else\n      a = t * (h - s) / this.zoomedOutWidth;\n    s + a < 0 ? a = -s : h + a > this.totalBytes && (a = this.totalBytes - h), s += a, h += a, s < 0 && (s = 0), h > this.totalBytes && (h = this.totalBytes), this.setViewport(s, h, !1);\n  }\n  setViewport(t, e, i) {\n    this.animationFromMin = this.viewportMin, this.animationFromMax = this.viewportMax, this.animationToMin = t, this.animationToMax = e, i ? this.animationStart = D() : this.animationStart = 0, this.invalidate();\n  }\n  updateHover(t) {\n    const e = this.hitTestNode(t);\n    this.changeHoveredNode(e), this.events.emit(\"hover\", e, t);\n  }\n}\nfunction ht(n, o) {\n  for (; o; ) {\n    if (o === n)\n      return !0;\n    o = o.parent;\n  }\n  return !1;\n}\nfunction I(n, o, t) {\n  if (n === o)\n    return;\n  const e = o.parent, i = e.size || 1;\n  let s = 0;\n  I(n, e, t);\n  for (const h of e.children) {\n    if (h === o) {\n      t.startAngle_ += t.sweepAngle_ * s / i, t.sweepAngle_ = h.size / i * t.sweepAngle_;\n      break;\n    }\n    s += h.size;\n  }\n  t.depth_ += 1;\n}\nconst L = {};\nfunction nt(n) {\n  return L[n] || (L[n] = 50 * 8 * Math.log(1 + Math.log(1 + n / 8))), L[n];\n}\nconst R = -Math.PI / 2;\nclass At extends q {\n  constructor(t, e = {}) {\n    for (; t.children.length === 1; )\n      t = t.children[0];\n    super(t, e);\n    l(this, \"currentNode\");\n    l(this, \"hoveredNode\");\n    l(this, \"centerX\", 0);\n    l(this, \"centerY\", 0);\n    l(this, \"animationStart\", 0);\n    l(this, \"radiusScale\", 1);\n    l(this, \"sourceDepth\", 0);\n    l(this, \"sourceStartAngle\", R);\n    l(this, \"sourceSweepAngle\", Math.PI * 2);\n    l(this, \"targetNode\");\n    l(this, \"targetDepth\", this.sourceDepth);\n    l(this, \"targetStartAngle\", this.sourceStartAngle);\n    l(this, \"targetSweepAngle\", this.sourceSweepAngle);\n    l(this, \"animatedNode\");\n    l(this, \"animatedDepth\", this.sourceDepth);\n    l(this, \"animatedStartAngle\", this.sourceStartAngle);\n    l(this, \"animatedSweepAngle\", this.sourceSweepAngle);\n    l(this, \"previousHoveredNode\");\n    l(this, \"historyStack\", []);\n    this.currentNode = t, this.targetNode = this.currentNode, this.animatedNode = this.currentNode, this.canvas.onmousemove = (i) => {\n      this.handleMouseMove(i);\n    }, this.canvas.onmouseout = (i) => {\n      this.changeHoveredNode(void 0), this.events.emit(\"hover\", null, i);\n    }, this.canvas.onclick = (i) => {\n      let s = this.hitTestNode(i);\n      if (!s)\n        return;\n      this.events.emit(\"click\", s, i);\n      let h = [];\n      s !== this.animatedNode.parent ? h = this.historyStack.concat(this.currentNode) : this.historyStack.length > 0 && (s = this.historyStack.pop(), h = this.historyStack.slice()), this.events.emit(\"click\", s, i), s.children.length > 0 ? (this.select(s), this.historyStack = h) : i.preventDefault();\n    }, this.el.append(this.canvas), this.resize(), Promise.resolve().then(() => this.resize()), this.disposables.push(j(() => this.resize())), this.disposables.push(G((i) => this.handleMouseMove(i)));\n  }\n  select(t, e) {\n    (this.currentNode !== t || this.root) && (this.currentNode = t || this.root, this.updateSunburst(e), this.events.emit(\"select\", t));\n  }\n  resize() {\n    this.width = this.el.clientWidth, this.height = this.width, this.centerX = this.width >> 1, this.centerY = this.height >> 1;\n    const t = 2 * Math.ceil(nt(this.maxDepth));\n    this.radiusScale = this.width / t, super.resize();\n  }\n  draw() {\n    this.c.clearRect(0, 0, this.width, this.height), this.drawNode(this.animatedNode, this.animatedDepth, this.computeRadius(this.animatedDepth), this.animatedStartAngle, this.animatedSweepAngle, 3, -1 / 0), this.c.strokeStyle = this.palette.stroke, this.c.beginPath(), this.drawNode(this.animatedNode, this.animatedDepth, this.computeRadius(this.animatedDepth), this.animatedStartAngle, this.animatedSweepAngle, 1, -1 / 0), this.c.stroke(), this.animatedDepth === 0 && (this.c.fillStyle = this.palette.stroke, this.setFont(ct), this.c.textAlign = \"center\", this.c.fillText(St(this.targetNode.size), this.centerX, this.centerY));\n  }\n  // We want to avoid overlapping strokes from lots of really small adjacent\n  // slices all merging together into a solid color. So we enforce a\n  // minimum slice width of 2px and we also skip drawing slices that\n  // have a tail edge less than 1.5px from the previous tail edge.\n  drawNode(t, e, i, s, h, a, r) {\n    const c = this.computeRadius(e + 1);\n    if (c > this.centerY)\n      return r;\n    t === this.hoveredNode && (a |= 8);\n    const d = (i + c) / 2, m = s + h;\n    if (m - r < 1.5 / d)\n      return r;\n    let u = 2 / d;\n    if (h > u && (u = h), a & 2)\n      this.c.fillStyle = $(this.getColor(t) || this.palette.fallback, this.c, this.centerX, this.centerY, 1), this.c.beginPath(), this.c.arc(this.centerX, this.centerY, i, s, s + u, !1), this.c.arc(this.centerX, this.centerY, c, s + u, s, !0), this.c.fill(), this.hoveredNode && (a & 8 || t.parent === this.hoveredNode) && (this.c.fillStyle = this.palette.hover, this.c.fill());\n    else {\n      const f = u === Math.PI * 2, N = a & 4 || f ? c : i;\n      a & 1 && i > 0 && this.c.arc(this.centerX, this.centerY, i, s + u, s, !0), this.c.moveTo(this.centerX + N * Math.cos(s), this.centerY + N * Math.sin(s)), this.c.arc(this.centerX, this.centerY, c, s, s + u, !1), f || this.c.lineTo(this.centerX + i * Math.cos(s + u), this.centerY + i * Math.sin(s + u));\n    }\n    const p = t.size;\n    let v = a & 10, g = 0, w = -1 / 0;\n    for (const f of t.children)\n      w = this.drawNode(f, e + 1, c, s + h * g / p, f.size / p * h, v, w), g += f.size, v |= 4;\n    return m;\n  }\n  changeHoveredNode(t, e) {\n    this.hoveredNode !== t && (this.hoveredNode = t, this.updateSunburst(e));\n  }\n  hitTestNode(t) {\n    const e = this.canvas.getBoundingClientRect(), i = t.clientX - e.left - this.centerX, s = t.clientY - e.top - this.centerY, h = Math.sqrt(i * i + s * s), a = Math.atan2(s, i), r = (c, d, m, u, p) => {\n      const v = this.computeRadius(d + 1);\n      if (v > this.centerY)\n        return;\n      if (h >= m && h < v) {\n        let f = a - u;\n        if (f /= Math.PI * 2, f -= Math.floor(f), f *= Math.PI * 2, f < p)\n          return c === this.animatedNode ? c.parent : c;\n      }\n      const g = c.size;\n      let w = 0;\n      for (const f of c.children) {\n        const N = r(f, d + 1, v, u + p * w / g, f.size / g * p);\n        if (N)\n          return N;\n        w += f.size;\n      }\n    };\n    return r(this.animatedNode, this.animatedDepth, this.computeRadius(this.animatedDepth), this.animatedStartAngle, this.animatedSweepAngle);\n  }\n  tick() {\n    let t = (D() - this.animationStart) / (this.options.animateDuration ?? _.animateDuration);\n    t < 0 || t > 1 ? (t = 1, this.animatedNode = this.targetNode, this.targetDepth = 0, this.targetStartAngle = R, this.targetSweepAngle = Math.PI * 2) : (t < 0.5 ? t *= 4 * t * t : (t = 1 - t, t *= 4 * t * t, t = 1 - t), this.invalidate()), this.animatedDepth = this.sourceDepth + (this.targetDepth - this.sourceDepth) * t, this.animatedStartAngle = this.sourceStartAngle + (this.targetStartAngle - this.sourceStartAngle) * t, this.animatedSweepAngle = this.sourceSweepAngle + (this.targetSweepAngle - this.sourceSweepAngle) * t, this.draw();\n  }\n  handleMouseMove(t) {\n    const e = this.hitTestNode(t);\n    this.changeHoveredNode(e), e && e !== this.animatedNode.parent ? (this.events.emit(\"hover\", e, t), this.canvas.style.cursor = \"pointer\") : this.events.emit(\"hover\", null, t);\n  }\n  computeRadius(t) {\n    return nt(t) * this.radiusScale;\n  }\n  updateSunburst(t = this.options.animate ?? !0) {\n    if (this.previousHoveredNode !== this.hoveredNode && (this.previousHoveredNode = this.hoveredNode, this.hoveredNode || (this.canvas.style.cursor = \"auto\", this.events.emit(\"hover\", null)), this.invalidate()), this.targetNode !== this.currentNode) {\n      if (this.historyStack.length = 0, this.invalidate(), t && (this.animationStart = D()), ht(this.animatedNode, this.currentNode)) {\n        const e = {\n          depth_: this.animatedDepth,\n          startAngle_: this.animatedStartAngle,\n          sweepAngle_: this.animatedSweepAngle\n        };\n        I(this.animatedNode, this.currentNode, e), this.animatedDepth = e.depth_, this.animatedStartAngle = e.startAngle_, this.animatedSweepAngle = e.sweepAngle_, this.targetDepth = 0, this.targetStartAngle = R, this.targetSweepAngle = Math.PI * 2, this.animatedNode = this.currentNode;\n      } else if (ht(this.currentNode, this.animatedNode)) {\n        const e = {\n          depth_: 0,\n          startAngle_: R,\n          sweepAngle_: Math.PI * 2\n        };\n        I(this.currentNode, this.animatedNode, e), this.targetDepth = e.depth_, this.targetStartAngle = e.startAngle_, this.targetSweepAngle = e.sweepAngle_;\n      } else\n        this.animationStart = -1 / 0, this.animatedNode = this.currentNode;\n      this.sourceDepth = this.animatedDepth, this.sourceStartAngle = this.animatedStartAngle, this.sourceSweepAngle = this.animatedSweepAngle, this.targetNode = this.currentNode, this.events.emit(\"select\", this.currentNode);\n    }\n  }\n}\nconst A = 4, z = 20, P = 2 * A, C = z + A;\nfunction Y(n, o, t, e, i) {\n  const s = [], h = (r, c, d, m, u) => {\n    const p = n[r].size * u, v = n[c].size * u;\n    return Math.max(\n      d * d * p / (m * m),\n      m * m / (d * d * v)\n    );\n  };\n  return ((r, c, d, m, u) => {\n    for (; r < n.length; ) {\n      let p = 0;\n      for (let x = r; x < n.length; x++)\n        p += n[x].size;\n      const v = Math.min(m, u), g = m * u / p;\n      let w = r, f = 0, N = 0;\n      for (; w < n.length; ) {\n        const x = n[w].size * g, O = h(r, w, v, f + x, g);\n        if (w > r && N < O)\n          break;\n        f += x, N = O, w++;\n      }\n      const M = Math.round(f / v);\n      let T = 0;\n      for (let x = r; x < w; x++) {\n        const O = n[x], U = O.size * g, k = Math.round(v * T / f), Z = Math.round(v * (T + U) / f), [K, Q, B, F] = m >= u ? [c, d + k, M, Z - k] : [c + k, d, Z - k, M];\n        s.push({\n          node: O,\n          box: [K, Q, B, F],\n          children: B > P && F > C ? Y(\n            O.children,\n            K + A,\n            Q + z,\n            B - P,\n            F - C\n          ) : []\n        }), T += U;\n      }\n      r = w, m >= u ? (c += M, m -= M) : (d += M, u -= M);\n    }\n  })(0, o, t, e, i), s;\n}\nclass zt extends q {\n  constructor(t, e = {}) {\n    super(t, e);\n    l(this, \"hoveredNode\", null);\n    l(this, \"currentNode\", null);\n    l(this, \"bgOriginX\", 0);\n    l(this, \"bgOriginY\", 0);\n    l(this, \"layers\", {\n      base: null\n    });\n    l(this, \"baseLayoutCache\");\n    l(this, \"currentOriginX\", 0);\n    l(this, \"currentOriginY\", 0);\n    l(this, \"animationStart\", 0);\n    l(this, \"animationBlend\", 1);\n    l(this, \"animationSource\", null);\n    l(this, \"animationTarget\", null);\n    this.canvas.addEventListener(\"mousemove\", (i) => {\n      this.updateHover(i);\n    }), this.canvas.addEventListener(\"mouseout\", (i) => {\n      this.changeHoveredNode(null), this.events.emit(\"hover\", null, i);\n    }), this.el.addEventListener(\"click\", (i) => {\n      const s = this.hitTestNode(i);\n      if (s) {\n        const h = s.node;\n        this.events.emit(\"click\", h, i), h.children.length ? s !== this.layers.current ? (this.changeCurrentLayout(s), this.changeHoveredNode(null)) : this.updateHover(i) : this.updateHover(i);\n      } else this.currentNode && (this.changeCurrentLayout(null), this.updateHover(i));\n    }), this.el.append(this.canvas), this.resize(), Promise.resolve().then(() => this.resize()), this.disposables.push(G((i) => this.updateHover(i))), this.disposables.push(j(() => this.resize()));\n  }\n  select(t, e) {\n    let i = null;\n    t === this.root && (t = null), t ? i = this.searchFor([this.layers.current, this.layers.base], t) : i = null, this.changeCurrentLayout(i, e);\n  }\n  drawBaseLayout() {\n    !this.width || !this.height || (this.c.clearRect(0, 0, this.width, this.height), this.bgOriginX = this.bgOriginY = 0, this.baseLayoutCache ? this.c.putImageData(this.baseLayoutCache, 0, 0) : (this.drawLayout(this.layers.base, 0, []), this.baseLayoutCache = this.c.getImageData(0, 0, this.width * this.ratio, this.height * this.ratio)));\n  }\n  draw() {\n    this.drawBaseLayout(), this.layers.current || this.drawHoverHighlight(this.layers.base);\n    const t = this.layers.current ? this.animationSource ? this.animationTarget ? 1 : 1 - this.animationBlend : this.animationBlend : 0;\n    if (this.layers.current) {\n      const [e, i, s, h] = this.layers.base.box;\n      this.c.globalAlpha = 0.6 * (!this.layers.current || !this.animationSource ? 1 : t), this.c.fillStyle = this.palette.bg, this.c.fillRect(e, i, s, h), this.c.globalAlpha = 1;\n    }\n    if (this.layers.previous && this.drawLayout(this.layers.previous, 1, [this.layers.current]), this.layers.current) {\n      const [e, i, s, h] = this.layers.current.box, a = this.c.getTransform(), r = Math.sqrt(a.a * a.d);\n      this.c.save(), this.c.shadowColor = this.palette.shadow, this.c.shadowBlur = r * (30 * t), this.c.shadowOffsetX = r * (2 * this.width), this.c.shadowOffsetY = r * (2 * this.height + 15 * t), this.c.fillRect(e - 2 * this.width, i - 2 * this.height, s, h), this.c.restore(), this.bgOriginX = this.currentOriginX, this.bgOriginY = this.currentOriginY, this.drawLayout(this.layers.current, 0, []), this.drawHoverHighlight(this.layers.current);\n    }\n  }\n  tick() {\n    const t = this.animationBlend, e = this.currentNode;\n    this.animationBlend = (D() - this.animationStart) / (this.options.animateDuration ?? _.animateDuration), this.animationBlend < 0 || this.animationBlend > 1 ? (this.currentNode = this.animationTarget, this.layers.previous = void 0, this.animationBlend = 1) : (this.animationBlend = 1 - this.animationBlend, this.animationBlend *= this.animationBlend * this.animationBlend, this.animationBlend = 1 - this.animationBlend, this.invalidate()), (this.animationBlend !== t || this.currentNode !== e) && this.updateCurrentLayout(), this.draw();\n  }\n  resize() {\n    this.baseLayoutCache = void 0;\n    const t = this.width, e = this.height;\n    this.width = Math.min(this.el.clientWidth, 1600), this.height = Math.max(Math.round(this.width / 2), innerHeight - 200), (this.width !== t || this.height !== e || !this.layers.base) && (this.layers.base = Y([this.root], 0, 0, this.width - 1, this.height - 1)[0], this.updateCurrentLayout()), super.resize();\n  }\n  *iterateNodeToDraw(t, e, i) {\n    const s = t.node, [h, a, r, c] = t.box;\n    let d = (s === this.hoveredNode ? 1 : 0) | (t === this.animationTarget ? 2 : 0);\n    if (e === 1)\n      for (const m of i) {\n        if (!m)\n          continue;\n        const [u, p, v, g] = m.box;\n        if (h >= u && a >= p && h + r <= u + v && a + c <= p + g) {\n          e = 2;\n          break;\n        }\n      }\n    for (const m of t.children)\n      d |= yield* this.iterateNodeToDraw(m, e, i);\n    return e !== 2 && (yield t), d;\n  }\n  drawHoverHighlight(t) {\n    const e = this.iterateNodeToDraw(t, 0, []), i = this.c.globalCompositeOperation;\n    for (; ; ) {\n      const s = e.next();\n      if (s.done) {\n        this.c.globalCompositeOperation = i;\n        return;\n      }\n      const h = s.value.node;\n      if (this.hoveredNode === h) {\n        this.c.globalCompositeOperation = \"overlay\";\n        const [a, r, c, d] = s.value.box;\n        this.c.fillStyle = this.palette.hover, this.c.fillRect(a, r, c, d);\n      }\n    }\n  }\n  drawNodeBackground(t, e, i) {\n    const s = this.iterateNodeToDraw(t, e, i);\n    for (; ; ) {\n      const h = s.next();\n      if (h.done)\n        return h.value;\n      const [a, r, c, d] = h.value.box;\n      this.c.fillStyle = $(this.getColor(h.value.node) || this.palette.fallback, this.c, this.bgOriginX, this.bgOriginY, 1), h.value.children.length ? (this.c.fillRect(a, r, c, z), this.c.fillRect(a, r + d - A, c, A), this.c.fillRect(a, r + z, A, d - C), this.c.fillRect(a + c - A, r + z, A, d - C)) : this.c.fillRect(a, r, c, d);\n    }\n  }\n  drawLayout(t, e, i) {\n    this.drawNodeBackground(t, e, i), this.drawNodeForeground(t, e, i);\n  }\n  drawNodeForeground(t, e, i) {\n    const s = this.iterateNodeToDraw(t, e, i);\n    for (; ; ) {\n      const h = s.next();\n      if (h.done)\n        return;\n      const a = h.value.node, [r, c, d, m] = h.value.box;\n      if (lt(this.c, this.palette.stroke, r + 0.5, c + 0.5, d, m), m >= z) {\n        this.c.fillStyle = this.palette.text;\n        const u = d - P, p = c + Math.round(C / 2), [v, g] = this.textOverflowEllipsis(this.getText(a) || \"\", u);\n        let w = r + Math.round((d - g) / 2);\n        const f = this.getText(a), N = this.getSubtext(a);\n        if (v === f && a.children.length) {\n          let M = N || \"\";\n          M && f && (M = ` - ${M}`);\n          const [T, x] = this.textOverflowEllipsis(M, u - g);\n          w = r + Math.round((d - g - x) / 2), this.c.globalAlpha = 0.5, this.c.fillText(T, w + g, p), this.c.globalAlpha = 1;\n        }\n        if (this.c.fillText(v, w, p), m > C + 16 && !a.children.length) {\n          const [M, T] = this.textOverflowEllipsis(N || \"\", u);\n          this.c.globalAlpha = 0.5;\n          const x = f ? z : z / 2 + A;\n          this.c.fillText(M, r + Math.round((d - T) / 2), c + x + Math.round(m - C) / 2), this.c.globalAlpha = 1;\n        }\n      }\n    }\n  }\n  updateCurrentLayout() {\n    const t = this.options.selectedPaddingRatio ?? 0.2;\n    if (this.currentNode) {\n      const [e, i, s, h] = this.currentNode.box, a = e + s, r = i + h, c = Math.round(this.width * t / 2), d = Math.round(this.height * t / 2), m = this.width - c - 1, u = this.height - d - 1, p = this.animationTarget ? this.animationBlend : 1 - this.animationBlend, v = Math.round(e + (c - e) * p), g = Math.round(i + (d - i) * p), w = Math.round(a + (m - a) * p), f = Math.round(r + (u - r) * p), N = (M) => M - Math.floor(M / 64 - 0.5) * 64;\n      this.layers.current = Y([this.currentNode.node], v, g, w - v, f - g)[0], this.currentOriginX = N(-(e + a) / 2) * (1 - p) + (v + w) / 2, this.currentOriginY = N(-(i + r) / 2) * (1 - p) + (g + f) / 2;\n    } else\n      this.layers.current = void 0, this.currentOriginX = 0, this.currentOriginY = 0;\n  }\n  hitTestNode(t) {\n    const e = this.canvas.getBoundingClientRect(), i = t.clientX - e.left, s = t.clientY - e.top, h = (a, r) => {\n      for (const c of a) {\n        const [d, m, u, p] = c.box;\n        if (i >= d && s >= m && i < d + u && s < m + p)\n          return h(c.children, !1) || (r ? null : c);\n      }\n      return null;\n    };\n    return this.layers.current ? h([this.layers.current], !1) : h([this.layers.base], !0);\n  }\n  updateHover(t) {\n    const e = this.hitTestNode(t);\n    this.changeHoveredNode(e && e.node), this.events.emit(\"hover\", (e == null ? void 0 : e.node) || null, t);\n  }\n  changeHoveredNode(t) {\n    this.hoveredNode !== t && (this.hoveredNode = t, this.canvas.style.cursor = t && !t.children.length ? \"pointer\" : \"auto\", this.invalidate());\n  }\n  searchFor(t, e) {\n    for (const i of t) {\n      if (!i)\n        continue;\n      const s = i.node === e ? i : this.searchFor(i.children, e);\n      if (s)\n        return s;\n    }\n    return null;\n  }\n  changeCurrentLayout(t, e = this.options.animate) {\n    this.animationTarget !== t && (this.events.emit(\"select\", (t == null ? void 0 : t.node) || null), this.layers.previous = t ? this.layers.current : void 0, e && (this.animationBlend = 0, this.animationStart = D(), this.animationSource = this.currentNode), this.animationTarget = t, this.currentNode = t || this.searchFor([this.layers.base], this.currentNode.node), this.updateCurrentLayout(), this.invalidate());\n  }\n}\n\n//# sourceMappingURL=index-BfFEknL3.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3BvdGxpZ2h0anMvb3ZlcmxheS9kaXN0L2luZGV4LUJmRkVrbkwzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0IsT0FBTyxvQkFBb0IsS0FBSyxvQkFBb0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2WkFBNlosMkJBQTJCO0FBQ3hiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEdBQUcsS0FBSztBQUM5QjtBQUNBO0FBQ0EsNENBQTRDLE9BQU8sOEJBQThCLGFBQWEsa0NBQWtDLHNCQUFzQixTQUFTLDZCQUE2QjtBQUM1TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBLEdBQUc7QUFDSCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0NBQStDLEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsV0FBVyxtQ0FBbUMsWUFBWTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFhQUFxYSxZQUFZO0FBQ2piO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc2ZBQXNmLEVBQUU7QUFDeGY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEVBQUU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWdCRTtBQUNGIiwic291cmNlcyI6WyJDOlxcZ2l0aHViX2Nsb25lXFxqcDE5ODhjaGlsbFxcbmV4dGpzLXJlYWN0LXRlbXBsYXRlXFxteS1hcHBcXG5vZGVfbW9kdWxlc1xcQHNwb3RsaWdodGpzXFxvdmVybGF5XFxkaXN0XFxpbmRleC1CZkZFa25MMy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZHQgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgdXQgPSAobiwgbywgdCkgPT4gbyBpbiBuID8gZHQobiwgbywgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IG5bb10gPSB0O1xudmFyIGwgPSAobiwgbywgdCkgPT4gdXQobiwgdHlwZW9mIG8gIT0gXCJzeW1ib2xcIiA/IG8gKyBcIlwiIDogbywgdCk7XG5mdW5jdGlvbiBtdChuLCBvID0gMSwgdCA9IDEpIHtcbiAgY29uc3QgZSA9ICgwLjYgKyAwLjQgKiBNYXRoLm1heCgwLCBNYXRoLmNvcyhuKSkpICogbywgaSA9ICgwLjUgKyAwLjIgKiBNYXRoLm1heCgwLCBNYXRoLmNvcyhuICsgTWF0aC5QSSAqIDIgLyAzKSkpICogdDtcbiAgcmV0dXJuIGBoc2woJHtuICogMTgwIC8gTWF0aC5QSX1kZWcsICR7TWF0aC5yb3VuZCgxMDAgKiBlKX0lLCAke01hdGgucm91bmQoMTAwICogaSl9JSlgO1xufVxubGV0IEosIHR0LCBldCwgVywgUywgeSA9IDEsIEU7XG5mdW5jdGlvbiAkKG4sIG8sIHQsIGUsIGkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG4pKVxuICAgIHJldHVybiBuO1xuICBjb25zdCBzID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgaWYgKEogIT09IG8gfHwgdHQgIT09IHMgfHwgZXQgIT09IGkpIHtcbiAgICBjb25zdCBoID0gTWF0aC5yb3VuZCg2NCAqIHMpIC8gNjQ7XG4gICAgeSA9IGksIHkgPSBNYXRoLmxvZzIoeSksIHkgLT0gTWF0aC5mbG9vcih5KTtcbiAgICBjb25zdCBhID0geSwgciA9IE1hdGgubWluKDEsIDggKiBhKTtcbiAgICB5ID0gMiAqKiB5O1xuICAgIGNvbnN0IGMgPSA4ICogTWF0aC5TUVJUMiAvIHk7XG4gICAgSiA9IG8sIHR0ID0gcywgZXQgPSBpLCBXIHx8IChXID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSksIFMgfHwgKFMgPSBXLmdldENvbnRleHQoXCIyZFwiKSksIFcud2lkdGggPSBXLmhlaWdodCA9IE1hdGgucm91bmQoNjQgKiBoKSwgUy5zY2FsZShoLCBoKSwgUy5maWxsU3R5bGUgPSBuWzBdLCBTLmZpbGxSZWN0KDAsIDAsIDY0LCA2NCksIFMuZ2xvYmFsQWxwaGEgPSAwLjI1LCBTLmZpbGxTdHlsZSA9IG5bMV0sIFMuZmlsbFJlY3QoMCwgMCwgNjQsIDY0KSwgUy5nbG9iYWxBbHBoYSA9IDAuNjcsIFMuc3Ryb2tlU3R5bGUgPSBuWzFdLCBTLmJlZ2luUGF0aCgpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDw9IDY0OyBkICs9IDE2KVxuICAgICAgUy5tb3ZlVG8oZCAtIDMyLCBkICsgMzIpLCBTLmxpbmVUbyhkICsgMzIsIGQgLSAzMik7XG4gICAgaWYgKFMubGluZVdpZHRoID0gYyAqICgxIC0gKHIgLSBhKSAvIDIpLCBTLnN0cm9rZSgpLCByICsgYSA+IDApIHtcbiAgICAgIFMuYmVnaW5QYXRoKCk7XG4gICAgICBmb3IgKGxldCBkID0gODsgZCA8IDY0OyBkICs9IDE2KVxuICAgICAgICBTLm1vdmVUbyhkIC0gMzIsIGQgKyAzMiksIFMubGluZVRvKGQgKyAzMiwgZCAtIDMyKTtcbiAgICAgIFMubGluZVdpZHRoID0gYyAqIChyICsgYSkgLyAyLCBTLnN0cm9rZSgpO1xuICAgIH1cbiAgICBFID0gby5jcmVhdGVQYXR0ZXJuKFcsIFwicmVwZWF0XCIpLCB5IC89IGg7XG4gIH1cbiAgcmV0dXJuIHQgLz0gNjQgKiB5ICogcywgdCAtPSBNYXRoLmZsb29yKHQpLCB0ICo9IDY0ICogeSAqIHMsIEUuc2V0VHJhbnNmb3JtKG5ldyBET01NYXRyaXgoW1xuICAgIHksXG4gICAgMCxcbiAgICAwLFxuICAgIHksXG4gICAgdCxcbiAgICBlXG4gIF0pKSwgRTtcbn1cbmZ1bmN0aW9uIGZ0KG4pIHtcbiAgcmV0dXJuIChvKSA9PiBvLmlkICYmIG5bby5pZF0gfHwgby5jb2xvcjtcbn1cbmZ1bmN0aW9uIHB0KG4sIG8gPSAxLCB0ID0gMSkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBvdChlLCBuLCAwLCBNYXRoLlBJICogMiwgbywgdCksIGZ0KGUpO1xufVxuZnVuY3Rpb24gb3QobiwgbywgdCwgZSwgaSA9IDEsIHMgPSAxKSB7XG4gIGNvbnN0IGggPSBvLnNpemU7XG4gIG5bby5pZF0gPSBtdCh0ICsgZSAvIDIsIGksIHMpO1xuICBmb3IgKGNvbnN0IGEgb2Ygby5jaGlsZHJlbikge1xuICAgIGNvbnN0IHIgPSBhLnNpemUgLyBoICogZTtcbiAgICBvdChuLCBhLCB0LCByLCBpLCBzKSwgdCArPSByO1xuICB9XG59XG5jb25zdCB2dCA9IFwidXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdFwiO1xuZnVuY3Rpb24gZ3QobiA9IDE2LCBvID0gdnQpIHtcbiAgbGV0IHQgPSBcIlwiLCBlID0gbjtcbiAgY29uc3QgaSA9IG8ubGVuZ3RoO1xuICBmb3IgKDsgZS0tOyApXG4gICAgdCArPSBvW01hdGgucmFuZG9tKCkgKiBpIHwgMF07XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gd3QobiwgbywgdCA9IChlLCBpKSA9PiBpLnNpemUgLSBlLnNpemUpIHtcbiAgaWYgKG4uX19uYW5vdmlzKVxuICAgIHJldHVybiBuO1xuICBjb25zdCBlID0ge1xuICAgIC4uLm5cbiAgfTtcbiAgcmV0dXJuIGUuaWQgfHwgKGUuaWQgPSBndCgpKSwgZS5wYXJlbnQgfHwgKGUucGFyZW50ID0gbyksIGUuY2hpbGRyZW4gfHwgKGUuY2hpbGRyZW4gPSBbXSksIGUuc2l6ZVNlbGYgPT0gbnVsbCAmJiBlLnNpemUgIT0gbnVsbCAmJiBlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCA/IGUuc2l6ZVNlbGYgPSBlLnNpemUgOiBlLnNpemVTZWxmIHx8IChlLnNpemVTZWxmID0gMCksIGUuY2hpbGRyZW4gPSAoZS5jaGlsZHJlbiB8fCBbXSkubWFwKChpKSA9PiB3dChpLCBlLCB0KSksIGUuc2l6ZSB8fCAoZS5zaXplID0gZS5jaGlsZHJlbi5yZWR1Y2UoKGksIHMpID0+IGkgKyBzLnNpemUsIDApICsgZS5zaXplU2VsZiksIHQgJiYgZS5jaGlsZHJlbi5zb3J0KHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfX25hbm92aXNcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6ICEwIH0pLCBlO1xufVxuZnVuY3Rpb24gYXQobikge1xuICByZXR1cm4gbi5jaGlsZHJlbi5sZW5ndGggPT09IDAgPyAxIDogTWF0aC5tYXgoLi4ubi5jaGlsZHJlbi5tYXAoKG8pID0+IGF0KG8pKSkgKyAxO1xufVxuY29uc3QgTnQgPSAvXFxiRmlyZWZveFxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmxldCBYO1xuZnVuY3Rpb24gcnQobikge1xuICByZXR1cm4gWCA/IFguZm9ybWF0KG4pIDogYCR7bn1gO1xufVxuZnVuY3Rpb24gRCgpIHtcbiAgcmV0dXJuICh3aW5kb3cucGVyZm9ybWFuY2UgfHwgRGF0ZSkubm93KCk7XG59XG5mdW5jdGlvbiBIKG4pIHtcbiAgY29uc3QgbyA9IG4udG9GaXhlZCgxKS5zcGxpdChcIi5cIiwgMik7XG4gIHJldHVybiBgJHtydCgrb1swXSl9LiR7b1sxXX1gO1xufVxuZnVuY3Rpb24gU3Qobikge1xuICByZXR1cm4gbiA9PT0gMSA/IFwiMSBieXRlXCIgOiBuIDwgMTAyNCA/IGAke3J0KG4pfSBieXRlc2AgOiBuIDwgMTAyNCAqIDEwMjQgPyBgJHtIKG4gLyAxMDI0KX0ga2JgIDogbiA8IDEwMjQgKiAxMDI0ICogMTAyNCA/IGAke0gobiAvICgxMDI0ICogMTAyNCkpfSBtYmAgOiBgJHtIKG4gLyAoMTAyNCAqIDEwMjQgKiAxMDI0KSl9IGdiYDtcbn1cbmZ1bmN0aW9uIGx0KG4sIG8sIHQsIGUsIGksIHMpIHtcbiAgaWYgKE50KSB7XG4gICAgY29uc3QgaCA9IG4ubGluZVdpZHRoLCBhID0gaCAvIDI7XG4gICAgbi5maWxsU3R5bGUgPSBvLCBuLmZpbGxSZWN0KHQgLSBhLCBlIC0gYSwgaSArIGgsIGgpLCBuLmZpbGxSZWN0KHQgLSBhLCBlICsgYSwgaCwgcyAtIGgpLCBuLmZpbGxSZWN0KHQgLSBhLCBlICsgcyAtIGEsIGkgKyBoLCBoKSwgbi5maWxsUmVjdCh0ICsgaSAtIGEsIGUgKyBhLCBoLCBzIC0gaCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIG4uc3Ryb2tlU3R5bGUgPSBvLCBuLnN0cm9rZVJlY3QodCwgZSwgaSwgcyk7XG59XG5mdW5jdGlvbiBHKG4pIHtcbiAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgbiwgeyBwYXNzaXZlOiAhMSB9KSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBuKTtcbn1cbmZ1bmN0aW9uIGoobikge1xuICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbiksICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG4pO1xufVxudHJ5IHtcbiAgWCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdCgpO1xufSBjYXRjaCB7XG59XG5sZXQgTXQgPSAoKSA9PiAoe1xuICBlbWl0KG4sIC4uLm8pIHtcbiAgICBmb3IgKGxldCB0ID0gdGhpcy5ldmVudHNbbl0gfHwgW10sIGUgPSAwLCBpID0gdC5sZW5ndGg7IGUgPCBpOyBlKyspXG4gICAgICB0W2VdKC4uLm8pO1xuICB9LFxuICBldmVudHM6IHt9LFxuICBvbihuLCBvKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMuZXZlbnRzKVtuXSB8fCAodFtuXSA9IFtdKSkucHVzaChvKSwgKCkgPT4ge1xuICAgICAgdmFyIGU7XG4gICAgICB0aGlzLmV2ZW50c1tuXSA9IChlID0gdGhpcy5ldmVudHNbbl0pID09IG51bGwgPyB2b2lkIDAgOiBlLmZpbHRlcigoaSkgPT4gbyAhPT0gaSk7XG4gICAgfTtcbiAgfVxufSk7XG5jb25zdCBfID0ge1xuICBnZXRUZXh0OiAobikgPT4gbi50ZXh0LFxuICBnZXRTdWJ0ZXh0OiAobikgPT4gbi5zdWJ0ZXh0LFxuICBhbmltYXRlOiAhMCxcbiAgYW5pbWF0ZUR1cmF0aW9uOiAzNTBcbn0sIHh0ID0ge1xuICBmYWxsYmFjazogXCIjQ0NDXCIsXG4gIHN0cm9rZTogXCIjMDAwOFwiLFxuICB0ZXh0OiBcIiMyMjJcIixcbiAgaG92ZXI6IFwiI2ZmZjVcIixcbiAgc2hhZG93OiBcIiMwMDA4XCIsXG4gIGZnOiBcIiNmZmZcIixcbiAgYmc6IFwiIzIyMlwiXG59LCB5dCA9IDQ2LCBWID0gXCIxNHB4IHNhbnMtc2VyaWZcIiwgY3QgPSBgYm9sZCAke1Z9YDtcbmNsYXNzIHEge1xuICBjb25zdHJ1Y3RvcihvLCB0KSB7XG4gICAgbCh0aGlzLCBcImVsXCIpO1xuICAgIGwodGhpcywgXCJjYW52YXNcIik7XG4gICAgbCh0aGlzLCBcImNcIik7XG4gICAgbCh0aGlzLCBcIndpZHRoXCIsIDApO1xuICAgIGwodGhpcywgXCJoZWlnaHRcIiwgMCk7XG4gICAgbCh0aGlzLCBcInJhdGlvXCIsIDEpO1xuICAgIGwodGhpcywgXCJyb290XCIpO1xuICAgIGwodGhpcywgXCJtYXhEZXB0aFwiKTtcbiAgICBsKHRoaXMsIFwiZXZlbnRzXCIpO1xuICAgIGwodGhpcywgXCJvcHRpb25zXCIpO1xuICAgIGwodGhpcywgXCJwYWxldHRlXCIpO1xuICAgIGwodGhpcywgXCJkaXNwb3NhYmxlc1wiKTtcbiAgICBsKHRoaXMsIFwiZ2V0Q29sb3JcIik7XG4gICAgbCh0aGlzLCBcImdldFRleHRcIik7XG4gICAgbCh0aGlzLCBcImdldFN1YnRleHRcIik7XG4gICAgbCh0aGlzLCBcIl9hbmltYXRpb25GcmFtZVwiLCBudWxsKTtcbiAgICBsKHRoaXMsIFwiX2ZvbnRcIiwgXCIxNHB4IHNhbnMtc2VyaWZcIik7XG4gICAgbCh0aGlzLCBcIl9mb250V2lkdGhDYWNoZVwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBsKHRoaXMsIFwiZWxsaXBzaXNXaWR0aFwiLCAwKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAuLi5fLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgZ2V0Q29sb3I6IGUgPSBwdChvKSxcbiAgICAgIGdldFRleHQ6IGkgPSAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgZ2V0U3VidGV4dDogcyA9ICgpID0+IHtcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMucGFsZXR0ZSA9IHtcbiAgICAgIC4uLnh0LFxuICAgICAgLi4udC5wYWxldHRlXG4gICAgfSwgdGhpcy5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSwgdGhpcy5jID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLCB0aGlzLnJvb3QgPSBvLCB0aGlzLm1heERlcHRoID0gYXQobyksIHRoaXMuZGlzcG9zYWJsZXMgPSBbXSwgdGhpcy5ldmVudHMgPSBNdCgpLCB0aGlzLmdldENvbG9yID0gZSwgdGhpcy5nZXRUZXh0ID0gaSwgdGhpcy5nZXRTdWJ0ZXh0ID0gcywgdGhpcy5zZXRGb250KFYpLCB0Lm9uQ2xpY2sgJiYgdGhpcy5ldmVudHMub24oXCJjbGlja1wiLCB0Lm9uQ2xpY2spLCB0Lm9uSG92ZXIgJiYgdGhpcy5ldmVudHMub24oXCJob3ZlclwiLCB0Lm9uSG92ZXIpLCB0Lm9uTGVhdmUgJiYgdGhpcy5ldmVudHMub24oXCJsZWF2ZVwiLCB0Lm9uTGVhdmUpLCB0Lm9uU2VsZWN0ICYmIHRoaXMuZXZlbnRzLm9uKFwic2VsZWN0XCIsIHQub25TZWxlY3QpLCB0aGlzLmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJsZWF2ZVwiKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSW52YWxpZGF0ZSB0aGUgZ3JhcGggYW5kIHJlcXVlc3QgYSBuZXcgZnJhbWUuXG4gICAqL1xuICBpbnZhbGlkYXRlKCkge1xuICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lID09PSBudWxsICYmICh0aGlzLl9hbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRpb25GcmFtZSA9IG51bGwsIHRoaXMudGljaygpO1xuICAgIH0pKTtcbiAgfVxuICAvKipcbiAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRvIGltcGxlbWVudCBjdXN0b20gYW5pbWF0aW9uIGxvZ2ljLlxuICAgKi9cbiAgdGljaygpIHtcbiAgICB0aGlzLmRyYXcoKTtcbiAgfVxuICAvKipcbiAgICogVG8gYmUgb3ZlcnJpZGRlbiBieSBzdWJjbGFzc2VzIHRvIGltcGxlbWVudCBjdXN0b20gYW5pbWF0aW9uIGxvZ2ljLlxuICAgKi9cbiAgZHJhdygpIHtcbiAgfVxuICByZXNpemUoKSB7XG4gICAgdGhpcy5yYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gYCR7dGhpcy53aWR0aH1weGAsIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuaGVpZ2h0fXB4YCwgdGhpcy5jYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiB0aGlzLnJhdGlvKSwgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHRoaXMucmF0aW8pLCB0aGlzLmMuc2NhbGUodGhpcy5yYXRpbywgdGhpcy5yYXRpbyksIHRoaXMuZHJhdygpO1xuICB9XG4gIC8qKlxuICAgKiBTZWxlY3QgYSBub2RlLiBUbyBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50IGN1c3RvbSBzZWxlY3Rpb24gbG9naWMuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gc2VsZWN0LlxuICAgKiBAcGFyYW0gX2FuaW1hdGUgLSBXaGV0aGVyIHRvIGFuaW1hdGUgdGhlIHNlbGVjdGlvbi5cbiAgICovXG4gIHNlbGVjdChvLCB0KSB7XG4gICAgdGhpcy5ldmVudHMuZW1pdChcInNlbGVjdFwiLCBvKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuZGlzcG9zYWJsZXMuZm9yRWFjaCgobykgPT4gbygpKSwgdGhpcy5kaXNwb3NhYmxlcy5sZW5ndGggPSAwLCB0aGlzLmVsLnJlbW92ZSgpO1xuICB9XG4gIFtTeW1ib2wuZGlzcG9zZV0oKSB7XG4gICAgdGhpcy5kaXNwb3NlKCk7XG4gIH1cbiAgZ2V0Rm9udENhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLl9mb250V2lkdGhDYWNoZS5oYXModGhpcy5fZm9udCkgfHwgdGhpcy5fZm9udFdpZHRoQ2FjaGUuc2V0KHRoaXMuX2ZvbnQsIHt9KSwgdGhpcy5fZm9udFdpZHRoQ2FjaGUuZ2V0KHRoaXMuX2ZvbnQpO1xuICB9XG4gIHNldEZvbnQobykge1xuICAgIHRoaXMuX2ZvbnQgPSBvLCB0aGlzLmMuZm9udCA9IG8sIHRoaXMuYy50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiLCB0aGlzLmVsbGlwc2lzV2lkdGggPSAzICogdGhpcy5jaGFyQ29kZVdpZHRoKHl0KTtcbiAgfVxuICBjaGFyQ29kZVdpZHRoKG8pIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRGb250Q2FjaGUoKTtcbiAgICBsZXQgZSA9IHRbb107XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCAmJiAoZSA9IHRoaXMuYy5tZWFzdXJlVGV4dChTdHJpbmcuZnJvbUNoYXJDb2RlKG8pKS53aWR0aCwgdFtvXSA9IGUpLCBlO1xuICB9XG4gIHRleHRPdmVyZmxvd0VsbGlwc2lzKG8sIHQpIHtcbiAgICBpZiAodCA8IHRoaXMuZWxsaXBzaXNXaWR0aClcbiAgICAgIHJldHVybiBbXCJcIiwgMF07XG4gICAgbGV0IGUgPSAwO1xuICAgIGNvbnN0IGkgPSBvLmxlbmd0aDtcbiAgICBsZXQgcyA9IDA7XG4gICAgZm9yICg7IHMgPCBpOyApIHtcbiAgICAgIGNvbnN0IGggPSB0aGlzLmNoYXJDb2RlV2lkdGgoby5jaGFyQ29kZUF0KHMpKTtcbiAgICAgIGlmICh0IDwgZSArIHRoaXMuZWxsaXBzaXNXaWR0aCArIGgpXG4gICAgICAgIHJldHVybiBbYCR7by5zbGljZSgwLCBzKX0uLi5gLCBlICsgdGhpcy5lbGxpcHNpc1dpZHRoXTtcbiAgICAgIGUgKz0gaCwgcysrO1xuICAgIH1cbiAgICByZXR1cm4gW28sIGVdO1xuICB9XG59XG5jb25zdCBiID0gMjQsIFR0ID0gNSwgaXQgPSAwLjAxLCBzdCA9IDFlMztcbmNsYXNzIE90IGV4dGVuZHMgcSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKHQsIGUpO1xuICAgIGwodGhpcywgXCJtYWluRWxcIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgbCh0aGlzLCBcInRvdGFsQnl0ZXNcIik7XG4gICAgbCh0aGlzLCBcInZpZXdwb3J0TWluXCIpO1xuICAgIGwodGhpcywgXCJ2aWV3cG9ydE1heFwiKTtcbiAgICBsKHRoaXMsIFwiem9vbWVkT3V0TWluXCIsIDApO1xuICAgIGwodGhpcywgXCJ6b29tZWRPdXRXaWR0aFwiLCAwKTtcbiAgICBsKHRoaXMsIFwicHJldldoZWVsVGltZVwiLCAwKTtcbiAgICBsKHRoaXMsIFwicHJldldoZWVsV2FzWm9vbVwiLCAhMSk7XG4gICAgbCh0aGlzLCBcInN0cmlwZVNjYWxlQWRqdXN0XCIsIDEpO1xuICAgIGwodGhpcywgXCJob3ZlcmVkTm9kZVwiLCBudWxsKTtcbiAgICBsKHRoaXMsIFwic2VsZWN0ZWROb2RlXCIsIG51bGwpO1xuICAgIGwodGhpcywgXCJub2RlU3RhcnRCeXRlc1wiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0aW9uRnJvbU1pblwiLCAwKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0aW9uRnJvbU1heFwiLCAwKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0aW9uVG9NaW5cIiwgMCk7XG4gICAgbCh0aGlzLCBcImFuaW1hdGlvblRvTWF4XCIsIDApO1xuICAgIGwodGhpcywgXCJhbmltYXRpb25TdGFydFwiLCAwKTtcbiAgICB0aGlzLnRvdGFsQnl0ZXMgPSB0LnNpemUsIHRoaXMudmlld3BvcnRNaW4gPSB0aGlzLmFuaW1hdGlvbkZyb21NaW4gPSB0aGlzLmFuaW1hdGlvblRvTWluID0gMCwgdGhpcy52aWV3cG9ydE1heCA9IHRoaXMuYW5pbWF0aW9uRnJvbU1heCA9IHRoaXMuYW5pbWF0aW9uVG9NYXggPSB0aGlzLnRvdGFsQnl0ZXMsIE9iamVjdC5hc3NpZ24odGhpcy5tYWluRWwuc3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICB9KSwgT2JqZWN0LmFzc2lnbih0aGlzLmNhbnZhcy5zdHlsZSwge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgdG9wOiBcIjBcIlxuICAgIH0pO1xuICAgIGxldCBpID0gITE7XG4gICAgdGhpcy5jYW52YXMub25tb3VzZWRvd24gPSAocykgPT4ge1xuICAgICAgaWYgKGkgPSAhMSwgcy5idXR0b24gIT09IDIpIHtcbiAgICAgICAgbGV0IGggPSBzLnBhZ2VYO1xuICAgICAgICBjb25zdCBhID0gKGMpID0+IHtcbiAgICAgICAgICBjb25zdCBkID0gYy5wYWdlWCAtIGg7XG4gICAgICAgICAgIWkgJiYgTWF0aC5hYnMoZCkgPCAzIHx8IChpID0gITAsIHRoaXMubW9kaWZ5Vmlld3BvcnQoLWQsIDAsIG51bGwpLCBoID0gYy5wYWdlWCk7XG4gICAgICAgIH0sIHIgPSAoKSA9PiB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBhKSwgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgcik7XG4gICAgICAgIH07XG4gICAgICAgIHMucHJldmVudERlZmF1bHQoKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBhKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgcik7XG4gICAgICB9XG4gICAgfSwgdGhpcy5jYW52YXMub25tb3VzZW1vdmUgPSAocykgPT4ge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlcihzKTtcbiAgICB9LCB0aGlzLmNhbnZhcy5vbm1vdXNlb3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5jaGFuZ2VIb3ZlcmVkTm9kZShudWxsKTtcbiAgICB9LCB0aGlzLmNhbnZhcy5vbmNsaWNrID0gKHMpID0+IHtcbiAgICAgIGlmIChpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBoID0gdGhpcy5oaXRUZXN0Tm9kZShzKTtcbiAgICAgIHRoaXMuY2hhbmdlSG92ZXJlZE5vZGUoaCksIHRoaXMuY2hhbmdlU2VsZWN0ZWROb2RlKGgpLCBoICYmIHRoaXMuZXZlbnRzLmVtaXQoXCJjbGlja1wiLCBoLCBzKTtcbiAgICB9LCB0aGlzLmRpc3Bvc2FibGVzLnB1c2goRygocykgPT4ge1xuICAgICAgY29uc3QgaCA9IHMuZGVsdGFYLCBhID0gcy5kZWx0YVksIHIgPSBEKCksIGMgPSByIC0gdGhpcy5wcmV2V2hlZWxUaW1lIDwgNTAgPyB0aGlzLnByZXZXaGVlbFdhc1pvb20gOiBzLmN0cmxLZXkgfHwgcy5tZXRhS2V5O1xuICAgICAgdGhpcy5wcmV2V2hlZWxUaW1lID0gciwgdGhpcy5wcmV2V2hlZWxXYXNab29tID0gYywgKGMgfHwgTWF0aC5hYnMoaCkgPj0gTWF0aC5hYnMoYSkpICYmIHMucHJldmVudERlZmF1bHQoKSwgdGhpcy5tb2RpZnlWaWV3cG9ydChoLCBhLCBjID8gcy5wYWdlWCA6IG51bGwpLCB0aGlzLnVwZGF0ZUhvdmVyKHMpO1xuICAgIH0pKSwgdGhpcy5yZXNpemUoKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJlc2l6ZSgpKSwgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKGooKCkgPT4gdGhpcy5yZXNpemUoKSkpLCB0aGlzLm1haW5FbC5hcHBlbmQodGhpcy5jYW52YXMpLCB0aGlzLmVsLmFwcGVuZCh0aGlzLm1haW5FbCk7XG4gIH1cbiAgdGljaygpIHtcbiAgICBsZXQgdCA9IChEKCkgLSB0aGlzLmFuaW1hdGlvblN0YXJ0KSAvICh0aGlzLm9wdGlvbnMuYW5pbWF0ZUR1cmF0aW9uID8/IF8uYW5pbWF0ZUR1cmF0aW9uKTtcbiAgICB0IDwgMCB8fCB0ID4gMSA/ICh0ID0gMSwgdGhpcy52aWV3cG9ydE1pbiA9IHRoaXMuYW5pbWF0aW9uVG9NaW4sIHRoaXMudmlld3BvcnRNYXggPSB0aGlzLmFuaW1hdGlvblRvTWF4KSA6ICh0IDwgMC41ID8gdCAqPSA0ICogdCAqIHQgOiAodCA9IDEgLSB0LCB0ICo9IDQgKiB0ICogdCwgdCA9IDEgLSB0KSwgdGhpcy52aWV3cG9ydE1pbiA9IHRoaXMuYW5pbWF0aW9uRnJvbU1pbiArICh0aGlzLmFuaW1hdGlvblRvTWluIC0gdGhpcy5hbmltYXRpb25Gcm9tTWluKSAqIHQsIHRoaXMudmlld3BvcnRNYXggPSB0aGlzLmFuaW1hdGlvbkZyb21NYXggKyAodGhpcy5hbmltYXRpb25Ub01heCAtIHRoaXMuYW5pbWF0aW9uRnJvbU1heCkgKiB0LCB0aGlzLmludmFsaWRhdGUoKSksIHRoaXMuZHJhdygpO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgdGhpcy5jLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksIHRoaXMuZHJhd05vZGUoXG4gICAgICB0aGlzLnJvb3QsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC0xIC8gMCxcbiAgICAgIDFcbiAgICAgIC8qIFJPT1QgKi9cbiAgICApO1xuICB9XG4gIGNoYW5nZVNlbGVjdGVkTm9kZSh0LCBlID0gdGhpcy5vcHRpb25zLmFuaW1hdGUgPz8gXy5hbmltYXRlKSB7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWROb2RlICE9PSB0ICYmICh0aGlzLnNlbGVjdGVkTm9kZSA9IHQsIHRoaXMuZXZlbnRzLmVtaXQoXCJzZWxlY3RcIiwgdCksIHQgJiYgdGhpcy5ub2RlU3RhcnRCeXRlcy5oYXModC5pZCkpKSB7XG4gICAgICBsZXQgaSA9IHRoaXMubm9kZVN0YXJ0Qnl0ZXMuZ2V0KHQuaWQpLCBzID0gaSArIHQuc2l6ZTtcbiAgICAgIGkgPSBNYXRoLm1heCgwLCBpIC0gdC5zaXplICogaXQpLCBzID0gTWF0aC5taW4odGhpcy50b3RhbEJ5dGVzLCBzICsgdC5zaXplICogaXQpLCB0aGlzLnNldFZpZXdwb3J0KGksIHMsIGUpO1xuICAgIH1cbiAgfVxuICBzZWxlY3QodCwgZSA9IHRoaXMub3B0aW9ucy5hbmltYXRlID8/IF8uYW5pbWF0ZSkge1xuICAgIHRoaXMuY2hhbmdlU2VsZWN0ZWROb2RlKHQsIGUpO1xuICB9XG4gIHJlc2l6ZSgpIHtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5lbC5jbGllbnRXaWR0aCwgdGhpcy5oZWlnaHQgPSB0aGlzLm1heERlcHRoICogYiArIDEsIHRoaXMuem9vbWVkT3V0TWluID0gdGhpcy53aWR0aCAtIHN0ID4+IDEsIHRoaXMuem9vbWVkT3V0V2lkdGggPSB0aGlzLnpvb21lZE91dE1pbiArIHN0LCB0aGlzLnpvb21lZE91dE1pbiA8IDAgJiYgKHRoaXMuem9vbWVkT3V0TWluID0gMCksIHRoaXMuem9vbWVkT3V0V2lkdGggPiB0aGlzLndpZHRoICYmICh0aGlzLnpvb21lZE91dFdpZHRoID0gdGhpcy53aWR0aCksIHRoaXMuem9vbWVkT3V0V2lkdGggLT0gdGhpcy56b29tZWRPdXRNaW4sIHRoaXMuc3RyaXBlU2NhbGVBZGp1c3QgPSB0aGlzLnRvdGFsQnl0ZXMgLyB0aGlzLnpvb21lZE91dFdpZHRoLCB0aGlzLm1haW5FbC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLmhlaWdodH1weGAsIHN1cGVyLnJlc2l6ZSgpO1xuICB9XG4gIC8vIFdlIHdhbnQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgc3Ryb2tlcyBmcm9tIGxvdHMgb2YgcmVhbGx5IHNtYWxsIGFkamFjZW50XG4gIC8vIHJlY3RhbmdsZXMgYWxsIG1lcmdpbmcgdG9nZXRoZXIgaW50byBhIHNvbGlkIGNvbG9yLiBTbyB3ZSBlbmZvcmNlIGFcbiAgLy8gbWluaW11bSByZWN0YW5nbGUgd2lkdGggb2YgMnB4IGFuZCB3ZSBhbHNvIHNraXAgZHJhd2luZyByZWN0YW5nbGVzIHRoYXRcbiAgLy8gaGF2ZSBhIHJpZ2h0IGVkZ2UgbGVzcyB0aGFuIDEuNXB4IGZyb20gdGhlIHByZXZpb3VzIHJpZ2h0IGVkZ2UuXG4gIGRyYXdOb2RlKHQsIGUsIGksIHMsIGgpIHtcbiAgICB0aGlzLm5vZGVTdGFydEJ5dGVzLnNldCh0LmlkLCBpKTtcbiAgICBjb25zdCBhID0gdGhpcy56b29tZWRPdXRXaWR0aCAvICh0aGlzLnZpZXdwb3J0TWF4IC0gdGhpcy52aWV3cG9ydE1pbiksIHIgPSB0aGlzLnpvb21lZE91dE1pbiArIChpIC0gdGhpcy52aWV3cG9ydE1pbikgKiBhLCBjID0gdC5zaXplICogYSwgZCA9IHIgKyBjO1xuICAgIGlmIChkIDwgcyArIDEuNSlcbiAgICAgIHJldHVybiBzO1xuICAgIGlmIChyICsgYyA8IDAgfHwgciA+IHRoaXMud2lkdGgpXG4gICAgICByZXR1cm4gZDtcbiAgICBjb25zdCBtID0gYyA8IDIgPyAyIDogYywgdSA9IChyID4gMCA/IHIgOiAwKSArIFR0LCBwID0gZSArIGIgLyAyO1xuICAgIGxldCB2ID0gdGhpcy5nZXRUZXh0KHQpIHx8IFwiXCIsIGcgPSB0aGlzLmdldFN1YnRleHQodCkgfHwgXCJcIiwgdywgZiA9IDA7XG4gICAgY29uc3QgTiA9IGMgKyByIC0gdSwgTSA9ICQodGhpcy5nZXRDb2xvcih0KSB8fCB0aGlzLnBhbGV0dGUuZmFsbGJhY2ssIHRoaXMuYywgdGhpcy56b29tZWRPdXRNaW4gLSB0aGlzLnZpZXdwb3J0TWluICogYSwgYiwgYSAqIHRoaXMuc3RyaXBlU2NhbGVBZGp1c3QpO1xuICAgIGxldCBUID0gdGhpcy5wYWxldHRlLnRleHQsIHggPSAtMSAvIDA7XG4gICAgaCAmIDEgPyAoVCA9IHRoaXMucGFsZXR0ZS5mZywgdGhpcy5zZXRGb250KGN0KSkgOiAodGhpcy5jLmZpbGxTdHlsZSA9IE0sIHRoaXMuYy5maWxsUmVjdChyLCBlLCBtLCBiKSwgKGggJiAyIHx8IHRoaXMuaG92ZXJlZE5vZGUgJiYgdC5pZCA9PT0gdGhpcy5ob3ZlcmVkTm9kZS5pZCkgJiYgKHRoaXMuYy5maWxsU3R5bGUgPSB0aGlzLnBhbGV0dGUuaG92ZXIsIHRoaXMuYy5maWxsUmVjdChyLCBlLCBtLCBiKSwgaCB8PSAyKSksIHRoaXMuZWxsaXBzaXNXaWR0aCA8IE4gJiYgKHcgPSB0aGlzLmMubWVhc3VyZVRleHQodikud2lkdGgsIHcgPD0gTiA/IGYgKz0gdyA6ICh2ID0gdGhpcy50ZXh0T3ZlcmZsb3dFbGxpcHNpcyh2LCBOKVswXSwgZiA9IE4pLCB0aGlzLmMuZmlsbFN0eWxlID0gVCwgdGhpcy5jLmZpbGxUZXh0KHYsIHUsIHApKSwgaCAmIDEgJiYgdGhpcy5zZXRGb250KFYpLCBmICsgdGhpcy5lbGxpcHNpc1dpZHRoIDwgTiAmJiAoZyAmJiB2ICYmIChnID0gYCAtICR7Z31gKSwgdyA9IHRoaXMuYy5tZWFzdXJlVGV4dChnKS53aWR0aCwgZiArIHcgPiBOICYmIChnID0gdGhpcy50ZXh0T3ZlcmZsb3dFbGxpcHNpcyhnLCBOIC0gZilbMF0pLCB0aGlzLmMuZ2xvYmFsQWxwaGEgPSAwLjUsIHRoaXMuYy5maWxsVGV4dChnLCB1ICsgZiwgcCksIHRoaXMuYy5nbG9iYWxBbHBoYSA9IDEpO1xuICAgIGZvciAoY29uc3QgTyBvZiB0LmNoaWxkcmVuKVxuICAgICAgeCA9IHRoaXMuZHJhd05vZGUoXG4gICAgICAgIE8sXG4gICAgICAgIGUgKyBiLFxuICAgICAgICBpLFxuICAgICAgICB4LFxuICAgICAgICBoICYgLTJcbiAgICAgICAgLyogUk9PVCAqL1xuICAgICAgKSwgaSArPSBPLnNpemU7XG4gICAgcmV0dXJuIGggJiAxIHx8IGx0KHRoaXMuYywgdGhpcy5wYWxldHRlLnN0cm9rZSwgciArIDAuNSwgZSArIDAuNSwgbSwgYiksIGQ7XG4gIH1cbiAgY2hhbmdlSG92ZXJlZE5vZGUodCkge1xuICAgIHRoaXMuaG92ZXJlZE5vZGUgIT09IHQgJiYgKHRoaXMuaG92ZXJlZE5vZGUgPSB0LCB0aGlzLmNhbnZhcy5zdHlsZS5jdXJzb3IgPSB0ICYmICF0LmNoaWxkcmVuLmxlbmd0aCA/IFwicG9pbnRlclwiIDogXCJhdXRvXCIsIHRoaXMuaW52YWxpZGF0ZSgpKTtcbiAgfVxuICBoaXRUZXN0Tm9kZSh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBpID0gdC5jbGllbnRYIC0gZS5sZWZ0LCBzID0gdC5jbGllbnRZIC0gZS50b3AsIGggPSB0aGlzLnZpZXdwb3J0TWluICsgKHRoaXMudmlld3BvcnRNYXggLSB0aGlzLnZpZXdwb3J0TWluKSAvIHRoaXMuem9vbWVkT3V0V2lkdGggKiAoaSAtIHRoaXMuem9vbWVkT3V0TWluKSwgYSA9IChyLCBjLCBkKSA9PiB7XG4gICAgICBpZiAoaCA+PSBkICYmIGggPCBkICsgci5zaXplKSB7XG4gICAgICAgIGlmIChzID49IGMgJiYgcyA8IGMgKyBiICYmIHIuaWQpXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGlmIChzID49IGMgKyBiKVxuICAgICAgICAgIGZvciAoY29uc3QgbSBvZiByLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gYShtLCBjICsgYiwgZCk7XG4gICAgICAgICAgICBpZiAodSlcbiAgICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgICAgICBkICs9IG0uc2l6ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBhKHRoaXMucm9vdCwgMCwgMCk7XG4gIH1cbiAgbW9kaWZ5Vmlld3BvcnQodCwgZSwgaSkge1xuICAgIGxldCBzID0gdGhpcy52aWV3cG9ydE1pbiwgaCA9IHRoaXMudmlld3BvcnRNYXgsIGEgPSAwO1xuICAgIGlmIChpICE9PSBudWxsKSB7XG4gICAgICBjb25zdCByID0gcyArIChoIC0gcykgLyB0aGlzLnpvb21lZE91dFdpZHRoICogKGkgLSB0aGlzLnpvb21lZE91dE1pbiksIGMgPSAxLjAxICoqIGU7XG4gICAgICBzID0gciArIChzIC0gcikgKiBjLCBoID0gciArIChoIC0gcikgKiBjO1xuICAgIH0gZWxzZVxuICAgICAgYSA9IHQgKiAoaCAtIHMpIC8gdGhpcy56b29tZWRPdXRXaWR0aDtcbiAgICBzICsgYSA8IDAgPyBhID0gLXMgOiBoICsgYSA+IHRoaXMudG90YWxCeXRlcyAmJiAoYSA9IHRoaXMudG90YWxCeXRlcyAtIGgpLCBzICs9IGEsIGggKz0gYSwgcyA8IDAgJiYgKHMgPSAwKSwgaCA+IHRoaXMudG90YWxCeXRlcyAmJiAoaCA9IHRoaXMudG90YWxCeXRlcyksIHRoaXMuc2V0Vmlld3BvcnQocywgaCwgITEpO1xuICB9XG4gIHNldFZpZXdwb3J0KHQsIGUsIGkpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb21NaW4gPSB0aGlzLnZpZXdwb3J0TWluLCB0aGlzLmFuaW1hdGlvbkZyb21NYXggPSB0aGlzLnZpZXdwb3J0TWF4LCB0aGlzLmFuaW1hdGlvblRvTWluID0gdCwgdGhpcy5hbmltYXRpb25Ub01heCA9IGUsIGkgPyB0aGlzLmFuaW1hdGlvblN0YXJ0ID0gRCgpIDogdGhpcy5hbmltYXRpb25TdGFydCA9IDAsIHRoaXMuaW52YWxpZGF0ZSgpO1xuICB9XG4gIHVwZGF0ZUhvdmVyKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5oaXRUZXN0Tm9kZSh0KTtcbiAgICB0aGlzLmNoYW5nZUhvdmVyZWROb2RlKGUpLCB0aGlzLmV2ZW50cy5lbWl0KFwiaG92ZXJcIiwgZSwgdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGh0KG4sIG8pIHtcbiAgZm9yICg7IG87ICkge1xuICAgIGlmIChvID09PSBuKVxuICAgICAgcmV0dXJuICEwO1xuICAgIG8gPSBvLnBhcmVudDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBJKG4sIG8sIHQpIHtcbiAgaWYgKG4gPT09IG8pXG4gICAgcmV0dXJuO1xuICBjb25zdCBlID0gby5wYXJlbnQsIGkgPSBlLnNpemUgfHwgMTtcbiAgbGV0IHMgPSAwO1xuICBJKG4sIGUsIHQpO1xuICBmb3IgKGNvbnN0IGggb2YgZS5jaGlsZHJlbikge1xuICAgIGlmIChoID09PSBvKSB7XG4gICAgICB0LnN0YXJ0QW5nbGVfICs9IHQuc3dlZXBBbmdsZV8gKiBzIC8gaSwgdC5zd2VlcEFuZ2xlXyA9IGguc2l6ZSAvIGkgKiB0LnN3ZWVwQW5nbGVfO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHMgKz0gaC5zaXplO1xuICB9XG4gIHQuZGVwdGhfICs9IDE7XG59XG5jb25zdCBMID0ge307XG5mdW5jdGlvbiBudChuKSB7XG4gIHJldHVybiBMW25dIHx8IChMW25dID0gNTAgKiA4ICogTWF0aC5sb2coMSArIE1hdGgubG9nKDEgKyBuIC8gOCkpKSwgTFtuXTtcbn1cbmNvbnN0IFIgPSAtTWF0aC5QSSAvIDI7XG5jbGFzcyBBdCBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBmb3IgKDsgdC5jaGlsZHJlbi5sZW5ndGggPT09IDE7IClcbiAgICAgIHQgPSB0LmNoaWxkcmVuWzBdO1xuICAgIHN1cGVyKHQsIGUpO1xuICAgIGwodGhpcywgXCJjdXJyZW50Tm9kZVwiKTtcbiAgICBsKHRoaXMsIFwiaG92ZXJlZE5vZGVcIik7XG4gICAgbCh0aGlzLCBcImNlbnRlclhcIiwgMCk7XG4gICAgbCh0aGlzLCBcImNlbnRlcllcIiwgMCk7XG4gICAgbCh0aGlzLCBcImFuaW1hdGlvblN0YXJ0XCIsIDApO1xuICAgIGwodGhpcywgXCJyYWRpdXNTY2FsZVwiLCAxKTtcbiAgICBsKHRoaXMsIFwic291cmNlRGVwdGhcIiwgMCk7XG4gICAgbCh0aGlzLCBcInNvdXJjZVN0YXJ0QW5nbGVcIiwgUik7XG4gICAgbCh0aGlzLCBcInNvdXJjZVN3ZWVwQW5nbGVcIiwgTWF0aC5QSSAqIDIpO1xuICAgIGwodGhpcywgXCJ0YXJnZXROb2RlXCIpO1xuICAgIGwodGhpcywgXCJ0YXJnZXREZXB0aFwiLCB0aGlzLnNvdXJjZURlcHRoKTtcbiAgICBsKHRoaXMsIFwidGFyZ2V0U3RhcnRBbmdsZVwiLCB0aGlzLnNvdXJjZVN0YXJ0QW5nbGUpO1xuICAgIGwodGhpcywgXCJ0YXJnZXRTd2VlcEFuZ2xlXCIsIHRoaXMuc291cmNlU3dlZXBBbmdsZSk7XG4gICAgbCh0aGlzLCBcImFuaW1hdGVkTm9kZVwiKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0ZWREZXB0aFwiLCB0aGlzLnNvdXJjZURlcHRoKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0ZWRTdGFydEFuZ2xlXCIsIHRoaXMuc291cmNlU3RhcnRBbmdsZSk7XG4gICAgbCh0aGlzLCBcImFuaW1hdGVkU3dlZXBBbmdsZVwiLCB0aGlzLnNvdXJjZVN3ZWVwQW5nbGUpO1xuICAgIGwodGhpcywgXCJwcmV2aW91c0hvdmVyZWROb2RlXCIpO1xuICAgIGwodGhpcywgXCJoaXN0b3J5U3RhY2tcIiwgW10pO1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSB0LCB0aGlzLnRhcmdldE5vZGUgPSB0aGlzLmN1cnJlbnROb2RlLCB0aGlzLmFuaW1hdGVkTm9kZSA9IHRoaXMuY3VycmVudE5vZGUsIHRoaXMuY2FudmFzLm9ubW91c2Vtb3ZlID0gKGkpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlTW91c2VNb3ZlKGkpO1xuICAgIH0sIHRoaXMuY2FudmFzLm9ubW91c2VvdXQgPSAoaSkgPT4ge1xuICAgICAgdGhpcy5jaGFuZ2VIb3ZlcmVkTm9kZSh2b2lkIDApLCB0aGlzLmV2ZW50cy5lbWl0KFwiaG92ZXJcIiwgbnVsbCwgaSk7XG4gICAgfSwgdGhpcy5jYW52YXMub25jbGljayA9IChpKSA9PiB7XG4gICAgICBsZXQgcyA9IHRoaXMuaGl0VGVzdE5vZGUoaSk7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJjbGlja1wiLCBzLCBpKTtcbiAgICAgIGxldCBoID0gW107XG4gICAgICBzICE9PSB0aGlzLmFuaW1hdGVkTm9kZS5wYXJlbnQgPyBoID0gdGhpcy5oaXN0b3J5U3RhY2suY29uY2F0KHRoaXMuY3VycmVudE5vZGUpIDogdGhpcy5oaXN0b3J5U3RhY2subGVuZ3RoID4gMCAmJiAocyA9IHRoaXMuaGlzdG9yeVN0YWNrLnBvcCgpLCBoID0gdGhpcy5oaXN0b3J5U3RhY2suc2xpY2UoKSksIHRoaXMuZXZlbnRzLmVtaXQoXCJjbGlja1wiLCBzLCBpKSwgcy5jaGlsZHJlbi5sZW5ndGggPiAwID8gKHRoaXMuc2VsZWN0KHMpLCB0aGlzLmhpc3RvcnlTdGFjayA9IGgpIDogaS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sIHRoaXMuZWwuYXBwZW5kKHRoaXMuY2FudmFzKSwgdGhpcy5yZXNpemUoKSwgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLnJlc2l6ZSgpKSwgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKGooKCkgPT4gdGhpcy5yZXNpemUoKSkpLCB0aGlzLmRpc3Bvc2FibGVzLnB1c2goRygoaSkgPT4gdGhpcy5oYW5kbGVNb3VzZU1vdmUoaSkpKTtcbiAgfVxuICBzZWxlY3QodCwgZSkge1xuICAgICh0aGlzLmN1cnJlbnROb2RlICE9PSB0IHx8IHRoaXMucm9vdCkgJiYgKHRoaXMuY3VycmVudE5vZGUgPSB0IHx8IHRoaXMucm9vdCwgdGhpcy51cGRhdGVTdW5idXJzdChlKSwgdGhpcy5ldmVudHMuZW1pdChcInNlbGVjdFwiLCB0KSk7XG4gIH1cbiAgcmVzaXplKCkge1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmVsLmNsaWVudFdpZHRoLCB0aGlzLmhlaWdodCA9IHRoaXMud2lkdGgsIHRoaXMuY2VudGVyWCA9IHRoaXMud2lkdGggPj4gMSwgdGhpcy5jZW50ZXJZID0gdGhpcy5oZWlnaHQgPj4gMTtcbiAgICBjb25zdCB0ID0gMiAqIE1hdGguY2VpbChudCh0aGlzLm1heERlcHRoKSk7XG4gICAgdGhpcy5yYWRpdXNTY2FsZSA9IHRoaXMud2lkdGggLyB0LCBzdXBlci5yZXNpemUoKTtcbiAgfVxuICBkcmF3KCkge1xuICAgIHRoaXMuYy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmRyYXdOb2RlKHRoaXMuYW5pbWF0ZWROb2RlLCB0aGlzLmFuaW1hdGVkRGVwdGgsIHRoaXMuY29tcHV0ZVJhZGl1cyh0aGlzLmFuaW1hdGVkRGVwdGgpLCB0aGlzLmFuaW1hdGVkU3RhcnRBbmdsZSwgdGhpcy5hbmltYXRlZFN3ZWVwQW5nbGUsIDMsIC0xIC8gMCksIHRoaXMuYy5zdHJva2VTdHlsZSA9IHRoaXMucGFsZXR0ZS5zdHJva2UsIHRoaXMuYy5iZWdpblBhdGgoKSwgdGhpcy5kcmF3Tm9kZSh0aGlzLmFuaW1hdGVkTm9kZSwgdGhpcy5hbmltYXRlZERlcHRoLCB0aGlzLmNvbXB1dGVSYWRpdXModGhpcy5hbmltYXRlZERlcHRoKSwgdGhpcy5hbmltYXRlZFN0YXJ0QW5nbGUsIHRoaXMuYW5pbWF0ZWRTd2VlcEFuZ2xlLCAxLCAtMSAvIDApLCB0aGlzLmMuc3Ryb2tlKCksIHRoaXMuYW5pbWF0ZWREZXB0aCA9PT0gMCAmJiAodGhpcy5jLmZpbGxTdHlsZSA9IHRoaXMucGFsZXR0ZS5zdHJva2UsIHRoaXMuc2V0Rm9udChjdCksIHRoaXMuYy50ZXh0QWxpZ24gPSBcImNlbnRlclwiLCB0aGlzLmMuZmlsbFRleHQoU3QodGhpcy50YXJnZXROb2RlLnNpemUpLCB0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSkpO1xuICB9XG4gIC8vIFdlIHdhbnQgdG8gYXZvaWQgb3ZlcmxhcHBpbmcgc3Ryb2tlcyBmcm9tIGxvdHMgb2YgcmVhbGx5IHNtYWxsIGFkamFjZW50XG4gIC8vIHNsaWNlcyBhbGwgbWVyZ2luZyB0b2dldGhlciBpbnRvIGEgc29saWQgY29sb3IuIFNvIHdlIGVuZm9yY2UgYVxuICAvLyBtaW5pbXVtIHNsaWNlIHdpZHRoIG9mIDJweCBhbmQgd2UgYWxzbyBza2lwIGRyYXdpbmcgc2xpY2VzIHRoYXRcbiAgLy8gaGF2ZSBhIHRhaWwgZWRnZSBsZXNzIHRoYW4gMS41cHggZnJvbSB0aGUgcHJldmlvdXMgdGFpbCBlZGdlLlxuICBkcmF3Tm9kZSh0LCBlLCBpLCBzLCBoLCBhLCByKSB7XG4gICAgY29uc3QgYyA9IHRoaXMuY29tcHV0ZVJhZGl1cyhlICsgMSk7XG4gICAgaWYgKGMgPiB0aGlzLmNlbnRlclkpXG4gICAgICByZXR1cm4gcjtcbiAgICB0ID09PSB0aGlzLmhvdmVyZWROb2RlICYmIChhIHw9IDgpO1xuICAgIGNvbnN0IGQgPSAoaSArIGMpIC8gMiwgbSA9IHMgKyBoO1xuICAgIGlmIChtIC0gciA8IDEuNSAvIGQpXG4gICAgICByZXR1cm4gcjtcbiAgICBsZXQgdSA9IDIgLyBkO1xuICAgIGlmIChoID4gdSAmJiAodSA9IGgpLCBhICYgMilcbiAgICAgIHRoaXMuYy5maWxsU3R5bGUgPSAkKHRoaXMuZ2V0Q29sb3IodCkgfHwgdGhpcy5wYWxldHRlLmZhbGxiYWNrLCB0aGlzLmMsIHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCAxKSwgdGhpcy5jLmJlZ2luUGF0aCgpLCB0aGlzLmMuYXJjKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCBpLCBzLCBzICsgdSwgITEpLCB0aGlzLmMuYXJjKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZLCBjLCBzICsgdSwgcywgITApLCB0aGlzLmMuZmlsbCgpLCB0aGlzLmhvdmVyZWROb2RlICYmIChhICYgOCB8fCB0LnBhcmVudCA9PT0gdGhpcy5ob3ZlcmVkTm9kZSkgJiYgKHRoaXMuYy5maWxsU3R5bGUgPSB0aGlzLnBhbGV0dGUuaG92ZXIsIHRoaXMuYy5maWxsKCkpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgZiA9IHUgPT09IE1hdGguUEkgKiAyLCBOID0gYSAmIDQgfHwgZiA/IGMgOiBpO1xuICAgICAgYSAmIDEgJiYgaSA+IDAgJiYgdGhpcy5jLmFyYyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgaSwgcyArIHUsIHMsICEwKSwgdGhpcy5jLm1vdmVUbyh0aGlzLmNlbnRlclggKyBOICogTWF0aC5jb3MocyksIHRoaXMuY2VudGVyWSArIE4gKiBNYXRoLnNpbihzKSksIHRoaXMuYy5hcmModGhpcy5jZW50ZXJYLCB0aGlzLmNlbnRlclksIGMsIHMsIHMgKyB1LCAhMSksIGYgfHwgdGhpcy5jLmxpbmVUbyh0aGlzLmNlbnRlclggKyBpICogTWF0aC5jb3MocyArIHUpLCB0aGlzLmNlbnRlclkgKyBpICogTWF0aC5zaW4ocyArIHUpKTtcbiAgICB9XG4gICAgY29uc3QgcCA9IHQuc2l6ZTtcbiAgICBsZXQgdiA9IGEgJiAxMCwgZyA9IDAsIHcgPSAtMSAvIDA7XG4gICAgZm9yIChjb25zdCBmIG9mIHQuY2hpbGRyZW4pXG4gICAgICB3ID0gdGhpcy5kcmF3Tm9kZShmLCBlICsgMSwgYywgcyArIGggKiBnIC8gcCwgZi5zaXplIC8gcCAqIGgsIHYsIHcpLCBnICs9IGYuc2l6ZSwgdiB8PSA0O1xuICAgIHJldHVybiBtO1xuICB9XG4gIGNoYW5nZUhvdmVyZWROb2RlKHQsIGUpIHtcbiAgICB0aGlzLmhvdmVyZWROb2RlICE9PSB0ICYmICh0aGlzLmhvdmVyZWROb2RlID0gdCwgdGhpcy51cGRhdGVTdW5idXJzdChlKSk7XG4gIH1cbiAgaGl0VGVzdE5vZGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaSA9IHQuY2xpZW50WCAtIGUubGVmdCAtIHRoaXMuY2VudGVyWCwgcyA9IHQuY2xpZW50WSAtIGUudG9wIC0gdGhpcy5jZW50ZXJZLCBoID0gTWF0aC5zcXJ0KGkgKiBpICsgcyAqIHMpLCBhID0gTWF0aC5hdGFuMihzLCBpKSwgciA9IChjLCBkLCBtLCB1LCBwKSA9PiB7XG4gICAgICBjb25zdCB2ID0gdGhpcy5jb21wdXRlUmFkaXVzKGQgKyAxKTtcbiAgICAgIGlmICh2ID4gdGhpcy5jZW50ZXJZKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoaCA+PSBtICYmIGggPCB2KSB7XG4gICAgICAgIGxldCBmID0gYSAtIHU7XG4gICAgICAgIGlmIChmIC89IE1hdGguUEkgKiAyLCBmIC09IE1hdGguZmxvb3IoZiksIGYgKj0gTWF0aC5QSSAqIDIsIGYgPCBwKVxuICAgICAgICAgIHJldHVybiBjID09PSB0aGlzLmFuaW1hdGVkTm9kZSA/IGMucGFyZW50IDogYztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGcgPSBjLnNpemU7XG4gICAgICBsZXQgdyA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgYy5jaGlsZHJlbikge1xuICAgICAgICBjb25zdCBOID0gcihmLCBkICsgMSwgdiwgdSArIHAgKiB3IC8gZywgZi5zaXplIC8gZyAqIHApO1xuICAgICAgICBpZiAoTilcbiAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgdyArPSBmLnNpemU7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcih0aGlzLmFuaW1hdGVkTm9kZSwgdGhpcy5hbmltYXRlZERlcHRoLCB0aGlzLmNvbXB1dGVSYWRpdXModGhpcy5hbmltYXRlZERlcHRoKSwgdGhpcy5hbmltYXRlZFN0YXJ0QW5nbGUsIHRoaXMuYW5pbWF0ZWRTd2VlcEFuZ2xlKTtcbiAgfVxuICB0aWNrKCkge1xuICAgIGxldCB0ID0gKEQoKSAtIHRoaXMuYW5pbWF0aW9uU3RhcnQpIC8gKHRoaXMub3B0aW9ucy5hbmltYXRlRHVyYXRpb24gPz8gXy5hbmltYXRlRHVyYXRpb24pO1xuICAgIHQgPCAwIHx8IHQgPiAxID8gKHQgPSAxLCB0aGlzLmFuaW1hdGVkTm9kZSA9IHRoaXMudGFyZ2V0Tm9kZSwgdGhpcy50YXJnZXREZXB0aCA9IDAsIHRoaXMudGFyZ2V0U3RhcnRBbmdsZSA9IFIsIHRoaXMudGFyZ2V0U3dlZXBBbmdsZSA9IE1hdGguUEkgKiAyKSA6ICh0IDwgMC41ID8gdCAqPSA0ICogdCAqIHQgOiAodCA9IDEgLSB0LCB0ICo9IDQgKiB0ICogdCwgdCA9IDEgLSB0KSwgdGhpcy5pbnZhbGlkYXRlKCkpLCB0aGlzLmFuaW1hdGVkRGVwdGggPSB0aGlzLnNvdXJjZURlcHRoICsgKHRoaXMudGFyZ2V0RGVwdGggLSB0aGlzLnNvdXJjZURlcHRoKSAqIHQsIHRoaXMuYW5pbWF0ZWRTdGFydEFuZ2xlID0gdGhpcy5zb3VyY2VTdGFydEFuZ2xlICsgKHRoaXMudGFyZ2V0U3RhcnRBbmdsZSAtIHRoaXMuc291cmNlU3RhcnRBbmdsZSkgKiB0LCB0aGlzLmFuaW1hdGVkU3dlZXBBbmdsZSA9IHRoaXMuc291cmNlU3dlZXBBbmdsZSArICh0aGlzLnRhcmdldFN3ZWVwQW5nbGUgLSB0aGlzLnNvdXJjZVN3ZWVwQW5nbGUpICogdCwgdGhpcy5kcmF3KCk7XG4gIH1cbiAgaGFuZGxlTW91c2VNb3ZlKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5oaXRUZXN0Tm9kZSh0KTtcbiAgICB0aGlzLmNoYW5nZUhvdmVyZWROb2RlKGUpLCBlICYmIGUgIT09IHRoaXMuYW5pbWF0ZWROb2RlLnBhcmVudCA/ICh0aGlzLmV2ZW50cy5lbWl0KFwiaG92ZXJcIiwgZSwgdCksIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwicG9pbnRlclwiKSA6IHRoaXMuZXZlbnRzLmVtaXQoXCJob3ZlclwiLCBudWxsLCB0KTtcbiAgfVxuICBjb21wdXRlUmFkaXVzKHQpIHtcbiAgICByZXR1cm4gbnQodCkgKiB0aGlzLnJhZGl1c1NjYWxlO1xuICB9XG4gIHVwZGF0ZVN1bmJ1cnN0KHQgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZSA/PyAhMCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzSG92ZXJlZE5vZGUgIT09IHRoaXMuaG92ZXJlZE5vZGUgJiYgKHRoaXMucHJldmlvdXNIb3ZlcmVkTm9kZSA9IHRoaXMuaG92ZXJlZE5vZGUsIHRoaXMuaG92ZXJlZE5vZGUgfHwgKHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IFwiYXV0b1wiLCB0aGlzLmV2ZW50cy5lbWl0KFwiaG92ZXJcIiwgbnVsbCkpLCB0aGlzLmludmFsaWRhdGUoKSksIHRoaXMudGFyZ2V0Tm9kZSAhPT0gdGhpcy5jdXJyZW50Tm9kZSkge1xuICAgICAgaWYgKHRoaXMuaGlzdG9yeVN0YWNrLmxlbmd0aCA9IDAsIHRoaXMuaW52YWxpZGF0ZSgpLCB0ICYmICh0aGlzLmFuaW1hdGlvblN0YXJ0ID0gRCgpKSwgaHQodGhpcy5hbmltYXRlZE5vZGUsIHRoaXMuY3VycmVudE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgZGVwdGhfOiB0aGlzLmFuaW1hdGVkRGVwdGgsXG4gICAgICAgICAgc3RhcnRBbmdsZV86IHRoaXMuYW5pbWF0ZWRTdGFydEFuZ2xlLFxuICAgICAgICAgIHN3ZWVwQW5nbGVfOiB0aGlzLmFuaW1hdGVkU3dlZXBBbmdsZVxuICAgICAgICB9O1xuICAgICAgICBJKHRoaXMuYW5pbWF0ZWROb2RlLCB0aGlzLmN1cnJlbnROb2RlLCBlKSwgdGhpcy5hbmltYXRlZERlcHRoID0gZS5kZXB0aF8sIHRoaXMuYW5pbWF0ZWRTdGFydEFuZ2xlID0gZS5zdGFydEFuZ2xlXywgdGhpcy5hbmltYXRlZFN3ZWVwQW5nbGUgPSBlLnN3ZWVwQW5nbGVfLCB0aGlzLnRhcmdldERlcHRoID0gMCwgdGhpcy50YXJnZXRTdGFydEFuZ2xlID0gUiwgdGhpcy50YXJnZXRTd2VlcEFuZ2xlID0gTWF0aC5QSSAqIDIsIHRoaXMuYW5pbWF0ZWROb2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoaHQodGhpcy5jdXJyZW50Tm9kZSwgdGhpcy5hbmltYXRlZE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGUgPSB7XG4gICAgICAgICAgZGVwdGhfOiAwLFxuICAgICAgICAgIHN0YXJ0QW5nbGVfOiBSLFxuICAgICAgICAgIHN3ZWVwQW5nbGVfOiBNYXRoLlBJICogMlxuICAgICAgICB9O1xuICAgICAgICBJKHRoaXMuY3VycmVudE5vZGUsIHRoaXMuYW5pbWF0ZWROb2RlLCBlKSwgdGhpcy50YXJnZXREZXB0aCA9IGUuZGVwdGhfLCB0aGlzLnRhcmdldFN0YXJ0QW5nbGUgPSBlLnN0YXJ0QW5nbGVfLCB0aGlzLnRhcmdldFN3ZWVwQW5nbGUgPSBlLnN3ZWVwQW5nbGVfO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3RhcnQgPSAtMSAvIDAsIHRoaXMuYW5pbWF0ZWROb2RlID0gdGhpcy5jdXJyZW50Tm9kZTtcbiAgICAgIHRoaXMuc291cmNlRGVwdGggPSB0aGlzLmFuaW1hdGVkRGVwdGgsIHRoaXMuc291cmNlU3RhcnRBbmdsZSA9IHRoaXMuYW5pbWF0ZWRTdGFydEFuZ2xlLCB0aGlzLnNvdXJjZVN3ZWVwQW5nbGUgPSB0aGlzLmFuaW1hdGVkU3dlZXBBbmdsZSwgdGhpcy50YXJnZXROb2RlID0gdGhpcy5jdXJyZW50Tm9kZSwgdGhpcy5ldmVudHMuZW1pdChcInNlbGVjdFwiLCB0aGlzLmN1cnJlbnROb2RlKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IEEgPSA0LCB6ID0gMjAsIFAgPSAyICogQSwgQyA9IHogKyBBO1xuZnVuY3Rpb24gWShuLCBvLCB0LCBlLCBpKSB7XG4gIGNvbnN0IHMgPSBbXSwgaCA9IChyLCBjLCBkLCBtLCB1KSA9PiB7XG4gICAgY29uc3QgcCA9IG5bcl0uc2l6ZSAqIHUsIHYgPSBuW2NdLnNpemUgKiB1O1xuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIGQgKiBkICogcCAvIChtICogbSksXG4gICAgICBtICogbSAvIChkICogZCAqIHYpXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuICgociwgYywgZCwgbSwgdSkgPT4ge1xuICAgIGZvciAoOyByIDwgbi5sZW5ndGg7ICkge1xuICAgICAgbGV0IHAgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IHI7IHggPCBuLmxlbmd0aDsgeCsrKVxuICAgICAgICBwICs9IG5beF0uc2l6ZTtcbiAgICAgIGNvbnN0IHYgPSBNYXRoLm1pbihtLCB1KSwgZyA9IG0gKiB1IC8gcDtcbiAgICAgIGxldCB3ID0gciwgZiA9IDAsIE4gPSAwO1xuICAgICAgZm9yICg7IHcgPCBuLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IHggPSBuW3ddLnNpemUgKiBnLCBPID0gaChyLCB3LCB2LCBmICsgeCwgZyk7XG4gICAgICAgIGlmICh3ID4gciAmJiBOIDwgTylcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZiArPSB4LCBOID0gTywgdysrO1xuICAgICAgfVxuICAgICAgY29uc3QgTSA9IE1hdGgucm91bmQoZiAvIHYpO1xuICAgICAgbGV0IFQgPSAwO1xuICAgICAgZm9yIChsZXQgeCA9IHI7IHggPCB3OyB4KyspIHtcbiAgICAgICAgY29uc3QgTyA9IG5beF0sIFUgPSBPLnNpemUgKiBnLCBrID0gTWF0aC5yb3VuZCh2ICogVCAvIGYpLCBaID0gTWF0aC5yb3VuZCh2ICogKFQgKyBVKSAvIGYpLCBbSywgUSwgQiwgRl0gPSBtID49IHUgPyBbYywgZCArIGssIE0sIFogLSBrXSA6IFtjICsgaywgZCwgWiAtIGssIE1dO1xuICAgICAgICBzLnB1c2goe1xuICAgICAgICAgIG5vZGU6IE8sXG4gICAgICAgICAgYm94OiBbSywgUSwgQiwgRl0sXG4gICAgICAgICAgY2hpbGRyZW46IEIgPiBQICYmIEYgPiBDID8gWShcbiAgICAgICAgICAgIE8uY2hpbGRyZW4sXG4gICAgICAgICAgICBLICsgQSxcbiAgICAgICAgICAgIFEgKyB6LFxuICAgICAgICAgICAgQiAtIFAsXG4gICAgICAgICAgICBGIC0gQ1xuICAgICAgICAgICkgOiBbXVxuICAgICAgICB9KSwgVCArPSBVO1xuICAgICAgfVxuICAgICAgciA9IHcsIG0gPj0gdSA/IChjICs9IE0sIG0gLT0gTSkgOiAoZCArPSBNLCB1IC09IE0pO1xuICAgIH1cbiAgfSkoMCwgbywgdCwgZSwgaSksIHM7XG59XG5jbGFzcyB6dCBleHRlbmRzIHEge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICBzdXBlcih0LCBlKTtcbiAgICBsKHRoaXMsIFwiaG92ZXJlZE5vZGVcIiwgbnVsbCk7XG4gICAgbCh0aGlzLCBcImN1cnJlbnROb2RlXCIsIG51bGwpO1xuICAgIGwodGhpcywgXCJiZ09yaWdpblhcIiwgMCk7XG4gICAgbCh0aGlzLCBcImJnT3JpZ2luWVwiLCAwKTtcbiAgICBsKHRoaXMsIFwibGF5ZXJzXCIsIHtcbiAgICAgIGJhc2U6IG51bGxcbiAgICB9KTtcbiAgICBsKHRoaXMsIFwiYmFzZUxheW91dENhY2hlXCIpO1xuICAgIGwodGhpcywgXCJjdXJyZW50T3JpZ2luWFwiLCAwKTtcbiAgICBsKHRoaXMsIFwiY3VycmVudE9yaWdpbllcIiwgMCk7XG4gICAgbCh0aGlzLCBcImFuaW1hdGlvblN0YXJ0XCIsIDApO1xuICAgIGwodGhpcywgXCJhbmltYXRpb25CbGVuZFwiLCAxKTtcbiAgICBsKHRoaXMsIFwiYW5pbWF0aW9uU291cmNlXCIsIG51bGwpO1xuICAgIGwodGhpcywgXCJhbmltYXRpb25UYXJnZXRcIiwgbnVsbCk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCAoaSkgPT4ge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlcihpKTtcbiAgICB9KSwgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIChpKSA9PiB7XG4gICAgICB0aGlzLmNoYW5nZUhvdmVyZWROb2RlKG51bGwpLCB0aGlzLmV2ZW50cy5lbWl0KFwiaG92ZXJcIiwgbnVsbCwgaSk7XG4gICAgfSksIHRoaXMuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChpKSA9PiB7XG4gICAgICBjb25zdCBzID0gdGhpcy5oaXRUZXN0Tm9kZShpKTtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGNvbnN0IGggPSBzLm5vZGU7XG4gICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoXCJjbGlja1wiLCBoLCBpKSwgaC5jaGlsZHJlbi5sZW5ndGggPyBzICE9PSB0aGlzLmxheWVycy5jdXJyZW50ID8gKHRoaXMuY2hhbmdlQ3VycmVudExheW91dChzKSwgdGhpcy5jaGFuZ2VIb3ZlcmVkTm9kZShudWxsKSkgOiB0aGlzLnVwZGF0ZUhvdmVyKGkpIDogdGhpcy51cGRhdGVIb3ZlcihpKTtcbiAgICAgIH0gZWxzZSB0aGlzLmN1cnJlbnROb2RlICYmICh0aGlzLmNoYW5nZUN1cnJlbnRMYXlvdXQobnVsbCksIHRoaXMudXBkYXRlSG92ZXIoaSkpO1xuICAgIH0pLCB0aGlzLmVsLmFwcGVuZCh0aGlzLmNhbnZhcyksIHRoaXMucmVzaXplKCksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy5yZXNpemUoKSksIHRoaXMuZGlzcG9zYWJsZXMucHVzaChHKChpKSA9PiB0aGlzLnVwZGF0ZUhvdmVyKGkpKSksIHRoaXMuZGlzcG9zYWJsZXMucHVzaChqKCgpID0+IHRoaXMucmVzaXplKCkpKTtcbiAgfVxuICBzZWxlY3QodCwgZSkge1xuICAgIGxldCBpID0gbnVsbDtcbiAgICB0ID09PSB0aGlzLnJvb3QgJiYgKHQgPSBudWxsKSwgdCA/IGkgPSB0aGlzLnNlYXJjaEZvcihbdGhpcy5sYXllcnMuY3VycmVudCwgdGhpcy5sYXllcnMuYmFzZV0sIHQpIDogaSA9IG51bGwsIHRoaXMuY2hhbmdlQ3VycmVudExheW91dChpLCBlKTtcbiAgfVxuICBkcmF3QmFzZUxheW91dCgpIHtcbiAgICAhdGhpcy53aWR0aCB8fCAhdGhpcy5oZWlnaHQgfHwgKHRoaXMuYy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpLCB0aGlzLmJnT3JpZ2luWCA9IHRoaXMuYmdPcmlnaW5ZID0gMCwgdGhpcy5iYXNlTGF5b3V0Q2FjaGUgPyB0aGlzLmMucHV0SW1hZ2VEYXRhKHRoaXMuYmFzZUxheW91dENhY2hlLCAwLCAwKSA6ICh0aGlzLmRyYXdMYXlvdXQodGhpcy5sYXllcnMuYmFzZSwgMCwgW10pLCB0aGlzLmJhc2VMYXlvdXRDYWNoZSA9IHRoaXMuYy5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMucmF0aW8sIHRoaXMuaGVpZ2h0ICogdGhpcy5yYXRpbykpKTtcbiAgfVxuICBkcmF3KCkge1xuICAgIHRoaXMuZHJhd0Jhc2VMYXlvdXQoKSwgdGhpcy5sYXllcnMuY3VycmVudCB8fCB0aGlzLmRyYXdIb3ZlckhpZ2hsaWdodCh0aGlzLmxheWVycy5iYXNlKTtcbiAgICBjb25zdCB0ID0gdGhpcy5sYXllcnMuY3VycmVudCA/IHRoaXMuYW5pbWF0aW9uU291cmNlID8gdGhpcy5hbmltYXRpb25UYXJnZXQgPyAxIDogMSAtIHRoaXMuYW5pbWF0aW9uQmxlbmQgOiB0aGlzLmFuaW1hdGlvbkJsZW5kIDogMDtcbiAgICBpZiAodGhpcy5sYXllcnMuY3VycmVudCkge1xuICAgICAgY29uc3QgW2UsIGksIHMsIGhdID0gdGhpcy5sYXllcnMuYmFzZS5ib3g7XG4gICAgICB0aGlzLmMuZ2xvYmFsQWxwaGEgPSAwLjYgKiAoIXRoaXMubGF5ZXJzLmN1cnJlbnQgfHwgIXRoaXMuYW5pbWF0aW9uU291cmNlID8gMSA6IHQpLCB0aGlzLmMuZmlsbFN0eWxlID0gdGhpcy5wYWxldHRlLmJnLCB0aGlzLmMuZmlsbFJlY3QoZSwgaSwgcywgaCksIHRoaXMuYy5nbG9iYWxBbHBoYSA9IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLmxheWVycy5wcmV2aW91cyAmJiB0aGlzLmRyYXdMYXlvdXQodGhpcy5sYXllcnMucHJldmlvdXMsIDEsIFt0aGlzLmxheWVycy5jdXJyZW50XSksIHRoaXMubGF5ZXJzLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IFtlLCBpLCBzLCBoXSA9IHRoaXMubGF5ZXJzLmN1cnJlbnQuYm94LCBhID0gdGhpcy5jLmdldFRyYW5zZm9ybSgpLCByID0gTWF0aC5zcXJ0KGEuYSAqIGEuZCk7XG4gICAgICB0aGlzLmMuc2F2ZSgpLCB0aGlzLmMuc2hhZG93Q29sb3IgPSB0aGlzLnBhbGV0dGUuc2hhZG93LCB0aGlzLmMuc2hhZG93Qmx1ciA9IHIgKiAoMzAgKiB0KSwgdGhpcy5jLnNoYWRvd09mZnNldFggPSByICogKDIgKiB0aGlzLndpZHRoKSwgdGhpcy5jLnNoYWRvd09mZnNldFkgPSByICogKDIgKiB0aGlzLmhlaWdodCArIDE1ICogdCksIHRoaXMuYy5maWxsUmVjdChlIC0gMiAqIHRoaXMud2lkdGgsIGkgLSAyICogdGhpcy5oZWlnaHQsIHMsIGgpLCB0aGlzLmMucmVzdG9yZSgpLCB0aGlzLmJnT3JpZ2luWCA9IHRoaXMuY3VycmVudE9yaWdpblgsIHRoaXMuYmdPcmlnaW5ZID0gdGhpcy5jdXJyZW50T3JpZ2luWSwgdGhpcy5kcmF3TGF5b3V0KHRoaXMubGF5ZXJzLmN1cnJlbnQsIDAsIFtdKSwgdGhpcy5kcmF3SG92ZXJIaWdobGlnaHQodGhpcy5sYXllcnMuY3VycmVudCk7XG4gICAgfVxuICB9XG4gIHRpY2soKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYW5pbWF0aW9uQmxlbmQsIGUgPSB0aGlzLmN1cnJlbnROb2RlO1xuICAgIHRoaXMuYW5pbWF0aW9uQmxlbmQgPSAoRCgpIC0gdGhpcy5hbmltYXRpb25TdGFydCkgLyAodGhpcy5vcHRpb25zLmFuaW1hdGVEdXJhdGlvbiA/PyBfLmFuaW1hdGVEdXJhdGlvbiksIHRoaXMuYW5pbWF0aW9uQmxlbmQgPCAwIHx8IHRoaXMuYW5pbWF0aW9uQmxlbmQgPiAxID8gKHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLmFuaW1hdGlvblRhcmdldCwgdGhpcy5sYXllcnMucHJldmlvdXMgPSB2b2lkIDAsIHRoaXMuYW5pbWF0aW9uQmxlbmQgPSAxKSA6ICh0aGlzLmFuaW1hdGlvbkJsZW5kID0gMSAtIHRoaXMuYW5pbWF0aW9uQmxlbmQsIHRoaXMuYW5pbWF0aW9uQmxlbmQgKj0gdGhpcy5hbmltYXRpb25CbGVuZCAqIHRoaXMuYW5pbWF0aW9uQmxlbmQsIHRoaXMuYW5pbWF0aW9uQmxlbmQgPSAxIC0gdGhpcy5hbmltYXRpb25CbGVuZCwgdGhpcy5pbnZhbGlkYXRlKCkpLCAodGhpcy5hbmltYXRpb25CbGVuZCAhPT0gdCB8fCB0aGlzLmN1cnJlbnROb2RlICE9PSBlKSAmJiB0aGlzLnVwZGF0ZUN1cnJlbnRMYXlvdXQoKSwgdGhpcy5kcmF3KCk7XG4gIH1cbiAgcmVzaXplKCkge1xuICAgIHRoaXMuYmFzZUxheW91dENhY2hlID0gdm9pZCAwO1xuICAgIGNvbnN0IHQgPSB0aGlzLndpZHRoLCBlID0gdGhpcy5oZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHRoaXMuZWwuY2xpZW50V2lkdGgsIDE2MDApLCB0aGlzLmhlaWdodCA9IE1hdGgubWF4KE1hdGgucm91bmQodGhpcy53aWR0aCAvIDIpLCBpbm5lckhlaWdodCAtIDIwMCksICh0aGlzLndpZHRoICE9PSB0IHx8IHRoaXMuaGVpZ2h0ICE9PSBlIHx8ICF0aGlzLmxheWVycy5iYXNlKSAmJiAodGhpcy5sYXllcnMuYmFzZSA9IFkoW3RoaXMucm9vdF0sIDAsIDAsIHRoaXMud2lkdGggLSAxLCB0aGlzLmhlaWdodCAtIDEpWzBdLCB0aGlzLnVwZGF0ZUN1cnJlbnRMYXlvdXQoKSksIHN1cGVyLnJlc2l6ZSgpO1xuICB9XG4gICppdGVyYXRlTm9kZVRvRHJhdyh0LCBlLCBpKSB7XG4gICAgY29uc3QgcyA9IHQubm9kZSwgW2gsIGEsIHIsIGNdID0gdC5ib3g7XG4gICAgbGV0IGQgPSAocyA9PT0gdGhpcy5ob3ZlcmVkTm9kZSA/IDEgOiAwKSB8ICh0ID09PSB0aGlzLmFuaW1hdGlvblRhcmdldCA/IDIgOiAwKTtcbiAgICBpZiAoZSA9PT0gMSlcbiAgICAgIGZvciAoY29uc3QgbSBvZiBpKSB7XG4gICAgICAgIGlmICghbSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgW3UsIHAsIHYsIGddID0gbS5ib3g7XG4gICAgICAgIGlmIChoID49IHUgJiYgYSA+PSBwICYmIGggKyByIDw9IHUgKyB2ICYmIGEgKyBjIDw9IHAgKyBnKSB7XG4gICAgICAgICAgZSA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBmb3IgKGNvbnN0IG0gb2YgdC5jaGlsZHJlbilcbiAgICAgIGQgfD0geWllbGQqIHRoaXMuaXRlcmF0ZU5vZGVUb0RyYXcobSwgZSwgaSk7XG4gICAgcmV0dXJuIGUgIT09IDIgJiYgKHlpZWxkIHQpLCBkO1xuICB9XG4gIGRyYXdIb3ZlckhpZ2hsaWdodCh0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaXRlcmF0ZU5vZGVUb0RyYXcodCwgMCwgW10pLCBpID0gdGhpcy5jLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGNvbnN0IHMgPSBlLm5leHQoKTtcbiAgICAgIGlmIChzLmRvbmUpIHtcbiAgICAgICAgdGhpcy5jLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGggPSBzLnZhbHVlLm5vZGU7XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSA9PT0gaCkge1xuICAgICAgICB0aGlzLmMuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJvdmVybGF5XCI7XG4gICAgICAgIGNvbnN0IFthLCByLCBjLCBkXSA9IHMudmFsdWUuYm94O1xuICAgICAgICB0aGlzLmMuZmlsbFN0eWxlID0gdGhpcy5wYWxldHRlLmhvdmVyLCB0aGlzLmMuZmlsbFJlY3QoYSwgciwgYywgZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdOb2RlQmFja2dyb3VuZCh0LCBlLCBpKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuaXRlcmF0ZU5vZGVUb0RyYXcodCwgZSwgaSk7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBjb25zdCBoID0gcy5uZXh0KCk7XG4gICAgICBpZiAoaC5kb25lKVxuICAgICAgICByZXR1cm4gaC52YWx1ZTtcbiAgICAgIGNvbnN0IFthLCByLCBjLCBkXSA9IGgudmFsdWUuYm94O1xuICAgICAgdGhpcy5jLmZpbGxTdHlsZSA9ICQodGhpcy5nZXRDb2xvcihoLnZhbHVlLm5vZGUpIHx8IHRoaXMucGFsZXR0ZS5mYWxsYmFjaywgdGhpcy5jLCB0aGlzLmJnT3JpZ2luWCwgdGhpcy5iZ09yaWdpblksIDEpLCBoLnZhbHVlLmNoaWxkcmVuLmxlbmd0aCA/ICh0aGlzLmMuZmlsbFJlY3QoYSwgciwgYywgeiksIHRoaXMuYy5maWxsUmVjdChhLCByICsgZCAtIEEsIGMsIEEpLCB0aGlzLmMuZmlsbFJlY3QoYSwgciArIHosIEEsIGQgLSBDKSwgdGhpcy5jLmZpbGxSZWN0KGEgKyBjIC0gQSwgciArIHosIEEsIGQgLSBDKSkgOiB0aGlzLmMuZmlsbFJlY3QoYSwgciwgYywgZCk7XG4gICAgfVxuICB9XG4gIGRyYXdMYXlvdXQodCwgZSwgaSkge1xuICAgIHRoaXMuZHJhd05vZGVCYWNrZ3JvdW5kKHQsIGUsIGkpLCB0aGlzLmRyYXdOb2RlRm9yZWdyb3VuZCh0LCBlLCBpKTtcbiAgfVxuICBkcmF3Tm9kZUZvcmVncm91bmQodCwgZSwgaSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLml0ZXJhdGVOb2RlVG9EcmF3KHQsIGUsIGkpO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgY29uc3QgaCA9IHMubmV4dCgpO1xuICAgICAgaWYgKGguZG9uZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYSA9IGgudmFsdWUubm9kZSwgW3IsIGMsIGQsIG1dID0gaC52YWx1ZS5ib3g7XG4gICAgICBpZiAobHQodGhpcy5jLCB0aGlzLnBhbGV0dGUuc3Ryb2tlLCByICsgMC41LCBjICsgMC41LCBkLCBtKSwgbSA+PSB6KSB7XG4gICAgICAgIHRoaXMuYy5maWxsU3R5bGUgPSB0aGlzLnBhbGV0dGUudGV4dDtcbiAgICAgICAgY29uc3QgdSA9IGQgLSBQLCBwID0gYyArIE1hdGgucm91bmQoQyAvIDIpLCBbdiwgZ10gPSB0aGlzLnRleHRPdmVyZmxvd0VsbGlwc2lzKHRoaXMuZ2V0VGV4dChhKSB8fCBcIlwiLCB1KTtcbiAgICAgICAgbGV0IHcgPSByICsgTWF0aC5yb3VuZCgoZCAtIGcpIC8gMik7XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldFRleHQoYSksIE4gPSB0aGlzLmdldFN1YnRleHQoYSk7XG4gICAgICAgIGlmICh2ID09PSBmICYmIGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IE0gPSBOIHx8IFwiXCI7XG4gICAgICAgICAgTSAmJiBmICYmIChNID0gYCAtICR7TX1gKTtcbiAgICAgICAgICBjb25zdCBbVCwgeF0gPSB0aGlzLnRleHRPdmVyZmxvd0VsbGlwc2lzKE0sIHUgLSBnKTtcbiAgICAgICAgICB3ID0gciArIE1hdGgucm91bmQoKGQgLSBnIC0geCkgLyAyKSwgdGhpcy5jLmdsb2JhbEFscGhhID0gMC41LCB0aGlzLmMuZmlsbFRleHQoVCwgdyArIGcsIHApLCB0aGlzLmMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmMuZmlsbFRleHQodiwgdywgcCksIG0gPiBDICsgMTYgJiYgIWEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgW00sIFRdID0gdGhpcy50ZXh0T3ZlcmZsb3dFbGxpcHNpcyhOIHx8IFwiXCIsIHUpO1xuICAgICAgICAgIHRoaXMuYy5nbG9iYWxBbHBoYSA9IDAuNTtcbiAgICAgICAgICBjb25zdCB4ID0gZiA/IHogOiB6IC8gMiArIEE7XG4gICAgICAgICAgdGhpcy5jLmZpbGxUZXh0KE0sIHIgKyBNYXRoLnJvdW5kKChkIC0gVCkgLyAyKSwgYyArIHggKyBNYXRoLnJvdW5kKG0gLSBDKSAvIDIpLCB0aGlzLmMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZUN1cnJlbnRMYXlvdXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZFBhZGRpbmdSYXRpbyA/PyAwLjI7XG4gICAgaWYgKHRoaXMuY3VycmVudE5vZGUpIHtcbiAgICAgIGNvbnN0IFtlLCBpLCBzLCBoXSA9IHRoaXMuY3VycmVudE5vZGUuYm94LCBhID0gZSArIHMsIHIgPSBpICsgaCwgYyA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHQgLyAyKSwgZCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiB0IC8gMiksIG0gPSB0aGlzLndpZHRoIC0gYyAtIDEsIHUgPSB0aGlzLmhlaWdodCAtIGQgLSAxLCBwID0gdGhpcy5hbmltYXRpb25UYXJnZXQgPyB0aGlzLmFuaW1hdGlvbkJsZW5kIDogMSAtIHRoaXMuYW5pbWF0aW9uQmxlbmQsIHYgPSBNYXRoLnJvdW5kKGUgKyAoYyAtIGUpICogcCksIGcgPSBNYXRoLnJvdW5kKGkgKyAoZCAtIGkpICogcCksIHcgPSBNYXRoLnJvdW5kKGEgKyAobSAtIGEpICogcCksIGYgPSBNYXRoLnJvdW5kKHIgKyAodSAtIHIpICogcCksIE4gPSAoTSkgPT4gTSAtIE1hdGguZmxvb3IoTSAvIDY0IC0gMC41KSAqIDY0O1xuICAgICAgdGhpcy5sYXllcnMuY3VycmVudCA9IFkoW3RoaXMuY3VycmVudE5vZGUubm9kZV0sIHYsIGcsIHcgLSB2LCBmIC0gZylbMF0sIHRoaXMuY3VycmVudE9yaWdpblggPSBOKC0oZSArIGEpIC8gMikgKiAoMSAtIHApICsgKHYgKyB3KSAvIDIsIHRoaXMuY3VycmVudE9yaWdpblkgPSBOKC0oaSArIHIpIC8gMikgKiAoMSAtIHApICsgKGcgKyBmKSAvIDI7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmxheWVycy5jdXJyZW50ID0gdm9pZCAwLCB0aGlzLmN1cnJlbnRPcmlnaW5YID0gMCwgdGhpcy5jdXJyZW50T3JpZ2luWSA9IDA7XG4gIH1cbiAgaGl0VGVzdE5vZGUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaSA9IHQuY2xpZW50WCAtIGUubGVmdCwgcyA9IHQuY2xpZW50WSAtIGUudG9wLCBoID0gKGEsIHIpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBhKSB7XG4gICAgICAgIGNvbnN0IFtkLCBtLCB1LCBwXSA9IGMuYm94O1xuICAgICAgICBpZiAoaSA+PSBkICYmIHMgPj0gbSAmJiBpIDwgZCArIHUgJiYgcyA8IG0gKyBwKVxuICAgICAgICAgIHJldHVybiBoKGMuY2hpbGRyZW4sICExKSB8fCAociA/IG51bGwgOiBjKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubGF5ZXJzLmN1cnJlbnQgPyBoKFt0aGlzLmxheWVycy5jdXJyZW50XSwgITEpIDogaChbdGhpcy5sYXllcnMuYmFzZV0sICEwKTtcbiAgfVxuICB1cGRhdGVIb3Zlcih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGl0VGVzdE5vZGUodCk7XG4gICAgdGhpcy5jaGFuZ2VIb3ZlcmVkTm9kZShlICYmIGUubm9kZSksIHRoaXMuZXZlbnRzLmVtaXQoXCJob3ZlclwiLCAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5ub2RlKSB8fCBudWxsLCB0KTtcbiAgfVxuICBjaGFuZ2VIb3ZlcmVkTm9kZSh0KSB7XG4gICAgdGhpcy5ob3ZlcmVkTm9kZSAhPT0gdCAmJiAodGhpcy5ob3ZlcmVkTm9kZSA9IHQsIHRoaXMuY2FudmFzLnN0eWxlLmN1cnNvciA9IHQgJiYgIXQuY2hpbGRyZW4ubGVuZ3RoID8gXCJwb2ludGVyXCIgOiBcImF1dG9cIiwgdGhpcy5pbnZhbGlkYXRlKCkpO1xuICB9XG4gIHNlYXJjaEZvcih0LCBlKSB7XG4gICAgZm9yIChjb25zdCBpIG9mIHQpIHtcbiAgICAgIGlmICghaSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzID0gaS5ub2RlID09PSBlID8gaSA6IHRoaXMuc2VhcmNoRm9yKGkuY2hpbGRyZW4sIGUpO1xuICAgICAgaWYgKHMpXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjaGFuZ2VDdXJyZW50TGF5b3V0KHQsIGUgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xuICAgIHRoaXMuYW5pbWF0aW9uVGFyZ2V0ICE9PSB0ICYmICh0aGlzLmV2ZW50cy5lbWl0KFwic2VsZWN0XCIsICh0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm5vZGUpIHx8IG51bGwpLCB0aGlzLmxheWVycy5wcmV2aW91cyA9IHQgPyB0aGlzLmxheWVycy5jdXJyZW50IDogdm9pZCAwLCBlICYmICh0aGlzLmFuaW1hdGlvbkJsZW5kID0gMCwgdGhpcy5hbmltYXRpb25TdGFydCA9IEQoKSwgdGhpcy5hbmltYXRpb25Tb3VyY2UgPSB0aGlzLmN1cnJlbnROb2RlKSwgdGhpcy5hbmltYXRpb25UYXJnZXQgPSB0LCB0aGlzLmN1cnJlbnROb2RlID0gdCB8fCB0aGlzLnNlYXJjaEZvcihbdGhpcy5sYXllcnMuYmFzZV0sIHRoaXMuY3VycmVudE5vZGUubm9kZSksIHRoaXMudXBkYXRlQ3VycmVudExheW91dCgpLCB0aGlzLmludmFsaWRhdGUoKSk7XG4gIH1cbn1cbmV4cG9ydCB7XG4gIGN0IGFzIENPTlNUQU5UX0JPTERfRk9OVCxcbiAgViBhcyBDT05TVEFOVF9OT1JNQUxfRk9OVCxcbiAgXyBhcyBERUZBVUxUX0dSQVBIX09QVElPTlMsXG4gIHh0IGFzIERFRkFVTFRfUEFMRVRURSxcbiAgT3QgYXMgRmxhbWVncmFwaCxcbiAgcSBhcyBHcmFwaEJhc2UsXG4gIEF0IGFzIFN1bmJ1cnN0LFxuICB6dCBhcyBUcmVlbWFwLFxuICAkIGFzIGNvbG9yVG9DYW52YXNGaWxsLFxuICBmdCBhcyBjcmVhdGVDb2xvckdldHRlckZyb21NYXAsXG4gIHB0IGFzIGNyZWF0ZUNvbG9yR2V0dGVyU3BlY3RydW0sXG4gIGF0IGFzIGdldFRyZWVNYXhEZXB0aCxcbiAgbXQgYXMgaHVlQW5nbGVUb0NvbG9yLFxuICB3dCBhcyBub3JtYWxpemVUcmVlTm9kZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LUJmRkVrbkwzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@spotlightjs/overlay/dist/index-BfFEknL3.js\n"));

/***/ })

}]);