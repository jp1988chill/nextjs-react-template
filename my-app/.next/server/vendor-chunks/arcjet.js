"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arcjet";
exports.ids = ["vendor-chunks/arcjet"];
exports.modules = {

/***/ "(middleware)/./node_modules/arcjet/index.js":
/*!**************************************!*\
  !*** ./node_modules/arcjet/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArcjetAllowDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetAllowDecision),\n/* harmony export */   ArcjetBotReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason),\n/* harmony export */   ArcjetChallengeDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetChallengeDecision),\n/* harmony export */   ArcjetDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDecision),\n/* harmony export */   ArcjetDenyDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision),\n/* harmony export */   ArcjetEdgeRuleReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEdgeRuleReason),\n/* harmony export */   ArcjetEmailReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason),\n/* harmony export */   ArcjetErrorDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision),\n/* harmony export */   ArcjetErrorReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason),\n/* harmony export */   ArcjetFilterReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetFilterReason),\n/* harmony export */   ArcjetIpDetails: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetIpDetails),\n/* harmony export */   ArcjetRateLimitReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason),\n/* harmony export */   ArcjetReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason),\n/* harmony export */   ArcjetRuleResult: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult),\n/* harmony export */   ArcjetSensitiveInfoReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason),\n/* harmony export */   ArcjetShieldReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason),\n/* harmony export */   botCategories: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.botCategories),\n/* harmony export */   \"default\": () => (/* binding */ arcjet),\n/* harmony export */   detectBot: () => (/* binding */ detectBot),\n/* harmony export */   filter: () => (/* binding */ filter),\n/* harmony export */   fixedWindow: () => (/* binding */ fixedWindow),\n/* harmony export */   protectSignup: () => (/* binding */ protectSignup),\n/* harmony export */   sensitiveInfo: () => (/* binding */ sensitiveInfo),\n/* harmony export */   shield: () => (/* binding */ shield),\n/* harmony export */   slidingWindow: () => (/* binding */ slidingWindow),\n/* harmony export */   tokenBucket: () => (/* binding */ tokenBucket),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcjet/protocol */ \"(middleware)/./node_modules/@arcjet/protocol/index.js\");\n/* harmony import */ var _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcjet/analyze */ \"(middleware)/./node_modules/@arcjet/analyze/index.js\");\n/* harmony import */ var _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcjet/duration */ \"(middleware)/./node_modules/@arcjet/duration/index.js\");\n/* harmony import */ var _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcjet/headers */ \"(middleware)/./node_modules/@arcjet/headers/index.js\");\n/* harmony import */ var _arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcjet/runtime */ \"(middleware)/./node_modules/@arcjet/runtime/index.js\");\n/* harmony import */ var _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcjet/stable-hash */ \"(middleware)/./node_modules/@arcjet/stable-hash/index.js\");\n/* harmony import */ var _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcjet/cache */ \"(middleware)/./node_modules/@arcjet/cache/index.js\");\n\n\n\n\n\n\n\n\n\n\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nfunction errorMessage(err) {\n    if (err) {\n        if (typeof err === \"string\") {\n            return err;\n        }\n        if (typeof err === \"object\" &&\n            \"message\" in err &&\n            typeof err.message === \"string\") {\n            return err.message;\n        }\n    }\n    return \"Unknown problem\";\n}\nconst knownFields = [\n    \"ip\",\n    \"method\",\n    \"protocol\",\n    \"host\",\n    \"path\",\n    \"headers\",\n    \"body\",\n    \"email\",\n    \"cookies\",\n    \"query\",\n];\nfunction isUnknownRequestProperty(key) {\n    return !knownFields.includes(key);\n}\nfunction isEmailType(type) {\n    return (type === \"FREE\" ||\n        type === \"DISPOSABLE\" ||\n        type === \"NO_MX_RECORDS\" ||\n        type === \"NO_GRAVATAR\" ||\n        type === \"INVALID\");\n}\nclass Performance {\n    log;\n    constructor(logger) {\n        this.log = logger;\n    }\n    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work\n    measure(label) {\n        const start = performance.now();\n        return () => {\n            const end = performance.now();\n            const diff = end - start;\n            this.log.debug(\"LATENCY %s: %sms\", label, diff.toFixed(3));\n        };\n    }\n}\nfunction toString(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return `${value}`;\n    }\n    if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n    }\n    return \"<unsupported value>\";\n}\n// This is the Symbol that Vercel defines in their infrastructure to access the\n// Context (where available). The Context can contain the `waitUntil` function.\n// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction lookupWaitUntil() {\n    const fromSymbol = globalThis;\n    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === \"object\" &&\n        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&\n        \"get\" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&\n        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === \"function\") {\n        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();\n        if (typeof vercelCtx === \"object\" &&\n            vercelCtx !== null &&\n            \"waitUntil\" in vercelCtx &&\n            typeof vercelCtx.waitUntil === \"function\") {\n            return vercelCtx.waitUntil;\n        }\n    }\n}\nfunction toAnalyzeRequest(request) {\n    const headers = {};\n    if (typeof request.headers !== \"undefined\") {\n        for (const [key, value] of request.headers.entries()) {\n            headers[key] = value;\n        }\n    }\n    return {\n        ...request,\n        headers,\n    };\n}\nfunction extraProps(details) {\n    const extra = new Map();\n    for (const [key, value] of Object.entries(details)) {\n        if (isUnknownRequestProperty(key)) {\n            extra.set(key, toString(value));\n        }\n    }\n    return Object.fromEntries(extra.entries());\n}\nfunction createTypeValidator(...types) {\n    return (key, value) => {\n        const typeOfValue = typeof value;\n        if (!types.includes(typeOfValue)) {\n            if (types.length === 1) {\n                throw new Error(`invalid type for \\`${key}\\` - expected ${types[0]}`);\n            }\n            else {\n                throw new Error(`invalid type for \\`${key}\\` - expected one of ${types.join(\", \")}`);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n}\nfunction createValueValidator(\n// This uses types to ensure we have at least 2 values\n...values) {\n    return (key, value) => {\n        // We cast the values to unknown because the optionValue isn't known but\n        // we only want to use `values` on string enumerations\n        if (!values.includes(value)) {\n            throw new Error(`invalid value for \\`${key}\\` - expected one of ${values.map((value) => `'${value}'`).join(\", \")}`);\n        }\n    };\n}\nfunction createArrayValidator(validate) {\n    return (key, value) => {\n        if (Array.isArray(value)) {\n            for (const [idx, item] of value.entries()) {\n                validate(`${key}[${idx}]`, item);\n            }\n        }\n        else {\n            throw new Error(`invalid type for \\`${key}\\` - expected an array`);\n        }\n    };\n}\nfunction createValidator({ rule, validations, }) {\n    return (options) => {\n        for (const { key, validate, required } of validations) {\n            if (required && !Object.hasOwn(options, key)) {\n                throw new Error(`\\`${rule}\\` options error: \\`${key}\\` is required`);\n            }\n            const value = options[key];\n            // The `required` flag is checked above, so these should only be validated\n            // if the value is not undefined.\n            if (typeof value !== \"undefined\") {\n                try {\n                    validate(key, value);\n                }\n                catch (err) {\n                    throw new Error(`\\`${rule}\\` options error: ${errorMessage(err)}`);\n                }\n            }\n        }\n    };\n}\nconst validateString = createTypeValidator(\"string\");\nconst validateNumber = createTypeValidator(\"number\");\nconst validateBoolean = createTypeValidator(\"boolean\");\nconst validateFunction = createTypeValidator(\"function\");\nconst validateStringOrNumber = createTypeValidator(\"string\", \"number\");\nconst validateStringArray = createArrayValidator(validateString);\nconst validateMode = createValueValidator(\"LIVE\", \"DRY_RUN\");\nconst validateEmailTypes = createArrayValidator(createValueValidator(\"DISPOSABLE\", \"FREE\", \"NO_MX_RECORDS\", \"NO_GRAVATAR\", \"INVALID\"));\nconst validateTokenBucketOptions = createValidator({\n    rule: \"tokenBucket\",\n    validations: [\n        {\n            key: \"mode\",\n            required: false,\n            validate: validateMode,\n        },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"refillRate\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n        { key: \"capacity\", required: true, validate: validateNumber },\n    ],\n});\nconst validateFixedWindowOptions = createValidator({\n    rule: \"fixedWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"window\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSlidingWindowOptions = createValidator({\n    rule: \"slidingWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSensitiveInfoOptions = createValidator({\n    rule: \"sensitiveInfo\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"contextWindowSize\", required: false, validate: validateNumber },\n        { key: \"detect\", required: false, validate: validateFunction },\n    ],\n});\nconst validateEmailOptions = createValidator({\n    rule: \"validateEmail\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"block\", required: false, validate: validateEmailTypes },\n        { key: \"allow\", required: false, validate: validateEmailTypes },\n        { key: \"deny\", required: false, validate: validateEmailTypes },\n        {\n            key: \"requireTopLevelDomain\",\n            required: false,\n            validate: validateBoolean,\n        },\n        { key: \"allowDomainLiteral\", required: false, validate: validateBoolean },\n    ],\n});\nconst validateBotOptions = createValidator({\n    rule: \"detectBot\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n    ],\n});\nconst validateShieldOptions = createValidator({\n    rule: \"shield\",\n    validations: [{ key: \"mode\", required: false, validate: validateMode }],\n});\n/**\n * Validate filter options.\n */\nconst validateFilterOptions = createValidator({\n    rule: \"filter\",\n    validations: [\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"mode\", required: false, validate: validateMode },\n    ],\n});\nconst Priority = {\n    SensitiveInfo: 1,\n    Filter: 2,\n    Shield: 3,\n    RateLimit: 4,\n    BotDetection: 5,\n    EmailValidation: 6,\n};\nfunction isRateLimitRule(rule) {\n    return rule.type === \"RATE_LIMIT\";\n}\n/**\n * Arcjet token bucket rate limiting rule.\n *\n * Applying this rule sets a token bucket rate limit.\n *\n * This algorithm is based on a bucket filled with a specific number of tokens.\n * Each request withdraws some amount of tokens from the bucket and the bucket\n * is refilled at a fixed rate.\n * Once the bucket is empty, the client is blocked until the bucket refills.\n *\n * This algorithm is useful when you want to allow clients to make a burst of\n * requests and then still be able to make requests at a slower rate.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the token bucket rate limiting rule (required).\n * @returns\n *   Token bucket rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   tokenBucket({\n *     mode: \"LIVE\",\n *     refillRate: 10,\n *     interval: \"60s\",\n *     capacity: 100,\n *   });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       tokenBucket({\n *         mode: \"LIVE\",\n *         refillRate: 10,\n *         interval: \"60s\",\n *         capacity: 100,\n *       }),\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#token-bucket\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction tokenBucket(options) {\n    validateTokenBucketOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const refillRate = options.refillRate;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const capacity = options.capacity;\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"TOKEN_BUCKET\",\n        refillRate,\n        interval,\n        capacity,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"TOKEN_BUCKET\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"refillRate\", refillRate), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"capacity\", capacity));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                    resetTime: new Date(),\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet fixed window rate limiting rule.\n *\n * Applying this rule sets a fixed window rate limit which tracks the number of\n * requests made by a client over a fixed time window.\n *\n * This is the simplest algorithm.\n * It tracks the number of requests made by a client over a fixed time window\n * such as 60 seconds.\n * If the client exceeds the limit, they are blocked until the window expires.\n *\n * This algorithm is useful when you want to apply a simple fixed limit in a\n * fixed time window.\n * For example, a simple limit on the total number of requests a client can make.\n * However, it can be susceptible to the stampede problem where a client makes\n * a burst of requests at the start of a window and then is blocked for the rest\n * of the window.\n * The sliding window algorithm can be used to avoid this.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the fixed window rate limiting rule (required).\n * @returns\n *   Fixed window rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   fixedWindow({ mode: \"LIVE\", window: \"60s\", max: 100 });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *      key: process.env.ARCJET_KEY,\n *     rules: [\n *       fixedWindow({\n *         mode: \"LIVE\",\n *         window: \"60s\",\n *         max: 100,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#fixed-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction fixedWindow(options) {\n    validateFixedWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const window = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.window);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"FIXED_WINDOW\",\n        max,\n        window,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"FIXED_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"window\", window));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet sliding window rate limiting rule.\n *\n * Applying this rule sets a sliding window rate limit which tracks the number\n * of requests made by a client over a sliding window so that the window moves\n * with time.\n *\n * This algorithm is useful to avoid the stampede problem of the fixed window.\n * It provides smoother rate limiting over time and can prevent a client from\n * making a burst of requests at the start of a window and then being blocked\n * for the rest of the window.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the sliding window rate limiting rule (required).\n * @returns\n *   Token bucket rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   slidingWindow({ mode: \"LIVE\", interval: \"60s\", max: 100 });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       slidingWindow({\n *         mode: \"LIVE\",\n *         interval: \"60s\",\n *         max: 100,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#sliding-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction slidingWindow(options) {\n    validateSlidingWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_2__.parse(options.interval);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"SLIDING_WINDOW\",\n        max,\n        interval,\n        validate() { },\n        async protect(context, details) {\n            const localCharacteristics = characteristics ?? context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"algorithm\", \"SLIDING_WINDOW\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics), \n            // Match is deprecated so it is always an empty string in the newest SDKs\n            _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"match\", \"\"), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"max\", max), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"interval\", interval));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached && cached.reason.isRateLimit()) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    // We rebuild the `ArcjetRateLimitReason` because we need to adjust\n                    // the `reset` based on the current time-to-live\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                        max: cached.reason.max,\n                        remaining: cached.reason.remaining,\n                        reset: ttl,\n                        window: cached.reason.window,\n                        resetTime: cached.reason.resetTime,\n                    }),\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason({\n                    max: 0,\n                    remaining: 0,\n                    reset: 0,\n                    window: 0,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\nfunction protocolSensitiveInfoEntitiesToAnalyze(entity) {\n    if (typeof entity !== \"string\") {\n        throw new Error(\"invalid entity type\");\n    }\n    if (entity === \"EMAIL\") {\n        return { tag: \"email\" };\n    }\n    if (entity === \"PHONE_NUMBER\") {\n        return { tag: \"phone-number\" };\n    }\n    if (entity === \"IP_ADDRESS\") {\n        return { tag: \"ip-address\" };\n    }\n    if (entity === \"CREDIT_CARD_NUMBER\") {\n        return { tag: \"credit-card-number\" };\n    }\n    return {\n        tag: \"custom\",\n        val: entity,\n    };\n}\nfunction analyzeSensitiveInfoEntitiesToString(entity) {\n    if (entity.tag === \"email\") {\n        return \"EMAIL\";\n    }\n    if (entity.tag === \"ip-address\") {\n        return \"IP_ADDRESS\";\n    }\n    if (entity.tag === \"credit-card-number\") {\n        return \"CREDIT_CARD_NUMBER\";\n    }\n    if (entity.tag === \"phone-number\") {\n        return \"PHONE_NUMBER\";\n    }\n    return entity.val;\n}\nfunction convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {\n    return detectedEntities.map((detectedEntity) => {\n        return {\n            ...detectedEntity,\n            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),\n        };\n    });\n}\n/**\n * Arcjet sensitive information detection rule.\n *\n * Applying this rule protects against clients sending you sensitive information\n * such as personally identifiable information (PII) that you do not wish to\n * handle.\n * The rule runs entirely locally so no data ever leaves your environment.\n *\n * This rule includes built-in detections for email addresses, credit/debit card\n * numbers, IP addresses, and phone numbers.\n * You can also provide a custom detection function to identify additional\n * sensitive information.\n *\n * @template Detect\n *   Custom detection function to identify sensitive information.\n * @template CustomEntities\n *   Custom entities.\n * @param options\n *   Configuration for the sensitive information detection rule (required).\n * @returns\n *   Sensitive information rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   sensitiveInfo({ mode: \"LIVE\", deny: [\"EMAIL\"] });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       sensitiveInfo({\n *         mode: \"LIVE\",\n *         deny: [\"EMAIL\"],\n *       })\n *     ],\n *   });\n *   ```\n * @example\n *   Custom detection function:\n *\n *   ```ts\n *   function detectDash(tokens: string[]): Array<\"CONTAINS_DASH\" | undefined> {\n *     return tokens.map((token) => {\n *       if (token.includes(\"-\")) {\n *         return \"CONTAINS_DASH\";\n *       }\n *     });\n *   }\n *\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       sensitiveInfo({\n *         mode: \"LIVE\",\n *         deny: [\"EMAIL\", \"CONTAINS_DASH\"],\n *         detect: detectDash,\n *         contextWindowSize: 2,\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/sensitive-info/concepts\n * @link https://docs.arcjet.com/sensitive-info/reference\n */\nfunction sensitiveInfo(options) {\n    validateSensitiveInfoOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"SENSITIVE_INFO\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow || [];\n    const deny = options.deny || [];\n    const rule = {\n        version,\n        priority: Priority.SensitiveInfo,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) { },\n        async protect(context, details) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the request body changes. This is also why the `sensitiveInfo`\n            // rule results always have a `ttl` of 0.\n            const body = await context.getBody();\n            if (typeof body === \"undefined\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state: \"NOT_RUN\",\n                    conclusion: \"ERROR\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Couldn't read the body of the request to perform sensitive info identification.\"),\n                });\n            }\n            let convertedDetect = undefined;\n            if (typeof options.detect !== \"undefined\") {\n                const detect = options.detect;\n                convertedDetect = (tokens) => {\n                    return detect(tokens)\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                };\n            }\n            let entitiesTag = \"allow\";\n            let entitiesVal = [];\n            if (Array.isArray(options.allow)) {\n                entitiesTag = \"allow\";\n                entitiesVal = options.allow\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            if (Array.isArray(options.deny)) {\n                entitiesTag = \"deny\";\n                entitiesVal = options.deny\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            const entities = {\n                tag: entitiesTag,\n                val: entitiesVal,\n            };\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            const reason = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason({\n                denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),\n                allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),\n            });\n            if (result.denied.length === 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason,\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason,\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet email validation rule.\n *\n * Applying this rule allows you to validate and verify an email address.\n *\n * The first step of the analysis is to validate the email address syntax.\n * This runs locally within the SDK and validates the email address is in the\n * correct format.\n * If the email syntax is valid, the SDK will pass the email address to the\n * Arcjet cloud API to verify the email address.\n * This performs several checks, depending on the rule configuration.\n *\n * @param options\n *   Configuration for the email validation rule (required).\n * @returns\n *   Email rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   validateEmail({ mode: \"LIVE\", deny: [\"DISPOSABLE\", \"INVALID\"] });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       validateEmail({\n *         mode: \"LIVE\",\n *         deny: [\"DISPOSABLE\", \"INVALID\"]\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/email-validation/concepts\n * @link https://docs.arcjet.com/email-validation/reference\n */\nfunction validateEmail(options) {\n    validateEmailOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `block` cannot be provided together\");\n    }\n    if (typeof options.deny !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `deny` and `block` cannot be provided together, `block` is now deprecated so `deny` should be preferred.\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\" &&\n        typeof options.block === \"undefined\") {\n        throw new Error(\"`validateEmail` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"EMAIL\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? options.block ?? [];\n    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;\n    const allowDomainLiteral = options.allowDomainLiteral ?? false;\n    let config = {\n        tag: \"deny-email-validation-config\",\n        val: {\n            requireTopLevelDomain,\n            allowDomainLiteral,\n            deny: [],\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allow-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                allow: options.allow,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.deny,\n            },\n        };\n    }\n    if (typeof options.block !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.block,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.EmailValidation,\n        type,\n        mode,\n        allow,\n        deny,\n        requireTopLevelDomain,\n        allowDomainLiteral,\n        validate(context, details) {\n            assert(typeof details.email !== \"undefined\", \"ValidateEmail requires `email` to be set.\");\n        },\n        async protect(context, { email }) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"requireTopLevelDomain\", requireTopLevelDomain), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.bool(\"allowDomainLiteral\", allowDomainLiteral));\n            const { fingerprint } = context;\n            // No cache is implemented here because the fingerprint can be the same\n            // while the email changes. This is also why the `email` rule results\n            // always have a `ttl` of 0.\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.isValidEmail(context, email, config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            if (result.validity === \"valid\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({ emailTypes: [] }),\n                });\n            }\n            else {\n                const typedEmailTypes = result.blocked.filter(isEmailType);\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({\n                        emailTypes: typedEmailTypes,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet bot detection rule.\n *\n * Applying this rule allows you to manage traffic by automated clients and\n * bots.\n *\n * Bots can be good (such as search engine crawlers or monitoring agents) or bad\n * (such as scrapers or automated scripts).\n * Arcjet allows you to configure which bots you want to allow or deny by\n * specific bot names such as curl, as well as by category such as search\n * engine bots.\n *\n * Bots are detected based on various signals such as the user agent, IP\n * address, DNS records, and more.\n *\n * @param options\n *   Configuration for the bot rule (required).\n * @returns\n *   Bot rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   Allow search engine bots and curl, deny all other bots:\n *\n *   ```ts\n *   detectBot({ mode: \"LIVE\", allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"] });\n *   ```\n * @example\n *   Allow search engine bots and curl, deny all other bots:\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       detectBot({\n *         mode: \"LIVE\",\n *         allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"]\n *       })\n *     ],\n *   });\n *   ```\n * @example\n *   Deny AI crawlers, allow all other bots:\n *\n *   ```ts\n *   detectBot({ mode: \"LIVE\", deny: [\"CATEGORY:AI\"] });\n *   ```\n * @example\n *   Deny AI crawlers, allows all other bots:\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *       detectBot({\n *         mode: \"LIVE\",\n *         deny: [\"CATEGORY:AI\"]\n *       })\n *     ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/bot-protection/concepts\n * @link https://docs.arcjet.com/bot-protection/identifying-bots\n * @link https://docs.arcjet.com/bot-protection/reference\n */\nfunction detectBot(options) {\n    validateBotOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`detectBot` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`detectBot` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"BOT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    let config = {\n        tag: \"allowed-bot-config\",\n        val: {\n            entities: [],\n            skipCustomDetect: true,\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allowed-bot-config\",\n            val: {\n                entities: options.allow,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"denied-bot-config\",\n            val: {\n                entities: options.deny,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.BotDetection,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) {\n            if (typeof details.headers === \"undefined\") {\n                throw new Error(\"bot detection requires `headers` to be set\");\n            }\n            if (typeof details.headers.has !== \"function\") {\n                throw new Error(\"bot detection requires `headers` to extend `Headers`\");\n            }\n            if (!details.headers.has(\"user-agent\")) {\n                throw new Error(\"bot detection requires user-agent header\");\n            }\n        },\n        /**\n         * Attempts to call the bot detection on the headers.\n         */\n        async protect(context, request) {\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", deny));\n            const { fingerprint } = context;\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.detectBot(context, toAnalyzeRequest(request), config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            // If this is a bot and of a type that we want to block, then block!\n            if (result.denied.length > 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 60,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet Shield WAF rule.\n *\n * Applying this rule protects your application against common attacks,\n * including the OWASP Top 10.\n *\n * The Arcjet Shield WAF analyzes every request to your application to detect\n * suspicious activity.\n * Once a certain suspicion threshold is reached,\n * subsequent requests from that client are blocked for a period of time.\n *\n * @param options\n *   Configuration for the Shield rule.\n * @returns\n *   Shield rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   ```ts\n *   shield({ mode: \"LIVE\" });\n *   ```\n * @example\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [shield({ mode: \"LIVE\" })],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/shield/concepts\n * @link https://docs.arcjet.com/shield/reference\n */\nfunction shield(options) {\n    validateShieldOptions(options);\n    const type = \"SHIELD\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const rule = {\n        type,\n        version,\n        priority: Priority.Shield,\n        mode,\n        validate() { },\n        async protect(context, details) {\n            // TODO(#1989): Prefer characteristics defined on rule once available\n            const localCharacteristics = context.characteristics;\n            const ruleId = await _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"characteristics\", localCharacteristics));\n            const analyzeContext = {\n                characteristics: localCharacteristics,\n                log: context.log,\n            };\n            const fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(analyzeContext, toAnalyzeRequest(details));\n            const [cached, ttl] = await context.cache.get(ruleId, fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    fingerprint,\n                    ttl,\n                    state: \"CACHED\",\n                    conclusion: cached.conclusion,\n                    reason: cached.reason,\n                });\n            }\n            return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ruleId,\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason({\n                    shieldTriggered: false,\n                }),\n            });\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet signup form protection rule.\n *\n * Applying this rule combines rate limiting, bot protection, and email\n * validation to protect your signup forms from abuse.\n * Using this rule will configure the following:\n *\n * - Rate limiting - signup forms are a common target for bots. Arcjet’s rate\n *   limiting helps to prevent bots and other automated or malicious clients\n *   from submitting your signup form too many times in a short period of time.\n * - Bot protection - signup forms are usually exclusively used by humans, which\n *   means that any automated submissions to the form are likely to be\n *   fraudulent.\n * - Email validation - email addresses should be validated to ensure the signup\n *   is coming from a legitimate user with a real email address that can\n *   actually receive messages.\n *\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration for the signup form protection rule.\n * @returns\n *   Signup form protection rule to provide to the SDK in the `rules` field.\n *\n * @example\n *   Our recommended configuration for most signup forms is:\n *\n *   - Block email addresses with invalid syntax, that are from disposable email providers,\n *     or do not have valid MX records configured.\n *   - Block all bots.\n *   - Apply a rate limit of 5 submissions per 10 minutes from a single IP\n *     address.\n *\n *   ```ts\n *   const aj = arcjet({\n *     key: process.env.ARCJET_KEY,\n *     rules: [\n *      protectSignup({\n *        email: {\n *          mode: \"LIVE\",\n *          block: [\"DISPOSABLE\", \"INVALID\", \"NO_MX_RECORDS\"],\n *        },\n *        bots: {\n *          mode: \"LIVE\",\n *          allow: [], // block all detected bots\n *        },\n *        rateLimit: {\n *          mode: \"LIVE\",\n *          interval: \"10m\",\n *          max: 5,\n *        },\n *      }),\n *    ],\n *   });\n *   ```\n *\n * @link https://docs.arcjet.com/signup-protection/concepts\n * @link https://docs.arcjet.com/signup-protection/reference\n */\nfunction protectSignup(options) {\n    return [\n        ...slidingWindow(options.rateLimit),\n        ...detectBot(options.bots),\n        ...validateEmail(options.email),\n    ];\n}\n/**\n * Arcjet filter rule.\n *\n * Applying this rule lets you block requests using Wireshark-like display\n * filter expressions over HTTP headers, IP addresses, and other request\n * fields.\n * You can quickly enforce rules like allow/deny by country, network, or\n * `user-agent` pattern.\n *\n * See the [reference guide](https://docs.arcjet.com/filters/reference) for\n * more info on the expression language fields, functions, and values.\n *\n * @param options\n *   Configuration (required).\n * @returns\n *   Filter rule.\n *\n * @example\n *   In this example, the expression matches non-VPN GET requests from the US.\n *   Requests matching the expression are allowed, all others are denied.\n *\n *   ```ts\n *   filter({\n *     allow: [\n *       'http.request.method eq \"GET\" and ip.src.country eq \"US\" and not ip.src.vpn',\n *     ],\n *     mode: \"LIVE\",\n *   })\n *   ```\n *\n * @link https://docs.arcjet.com/filters/reference\n */\nfunction filter(options) {\n    validateFilterOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    if (allow.length > 0 && deny.length > 0) {\n        throw new Error(\"`filter` options error: expressions must be passed in either `allow` or `deny` instead of both\");\n    }\n    if (allow.length === 0 && deny.length === 0) {\n        throw new Error(\"`filter` options error: one or more expressions must be passed in `allow` or `deny`\");\n    }\n    const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n    const type = \"FILTER\";\n    const version = 0;\n    const ruleIdPromise = _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"allow\", \n    // @ts-expect-error: `hasher` must support readonly values.\n    allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_5__.stringSliceOrdered(\"deny\", \n    // @ts-expect-error: `hasher` must support readonly values.\n    deny));\n    const rule = {\n        allow,\n        deny,\n        mode,\n        priority: Priority.Filter,\n        async protect(context, request) {\n            const ruleId = await ruleIdPromise;\n            const [cached, ttl] = await context.cache.get(ruleId, context.fingerprint);\n            if (cached) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: cached.conclusion,\n                    fingerprint: context.fingerprint,\n                    reason: cached.reason,\n                    ruleId,\n                    state: \"CACHED\",\n                    ttl,\n                });\n            }\n            const request_ = toAnalyzeRequest(request);\n            let ruleResult;\n            try {\n                const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.matchFilters(context, request_, allow.length > 0 ? allow : deny, allow.length > 0);\n                ruleResult = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: result.allowed ? \"ALLOW\" : \"DENY\",\n                    fingerprint: context.fingerprint,\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetFilterReason(result),\n                    ruleId,\n                    state,\n                    ttl: result.allowed ? 0 : 60,\n                });\n            }\n            catch (error) {\n                ruleResult = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    conclusion: \"ERROR\",\n                    fingerprint: context.fingerprint,\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(error),\n                    ruleId,\n                    state,\n                    ttl: 0,\n                });\n            }\n            return ruleResult;\n        },\n        type,\n        validate() { },\n        version,\n    };\n    return [rule];\n}\n/**\n * Create a new Arcjet instance.\n *\n * @template Rules\n *   List of rules.\n * @template Characteristics\n *   Characteristics to track a user by.\n * @param options\n *   Configuration.\n * @returns\n *   Arcjet instance.\n */\nfunction arcjet(options) {\n    // We destructure here to make the function signature neat when viewed by consumers\n    const { key, rules } = options;\n    const rt = (0,_arcjet_runtime__WEBPACK_IMPORTED_MODULE_4__.runtime)();\n    // TODO: Separate the ArcjetOptions from the SDK Options\n    // It is currently optional in the options so users can override it via an SDK\n    if (typeof options.log === \"undefined\") {\n        throw new Error(\"Log is required\");\n    }\n    const log = options.log;\n    const perf = new Performance(log);\n    // TODO(#207): Remove this when we can default the transport so client is not required\n    // It is currently optional in the options so the Next SDK can override it for the user\n    if (typeof options.client === \"undefined\") {\n        throw new Error(\"Client is required\");\n    }\n    const client = options.client;\n    // A local cache of block decisions. Might be emphemeral per request,\n    // depending on the way the runtime works, but it's worth a try.\n    // TODO(#132): Support configurable caching\n    const cache = new _arcjet_cache__WEBPACK_IMPORTED_MODULE_6__.MemoryCache();\n    const rootRules = rules\n        .flat(1)\n        .sort((a, b) => a.priority - b.priority);\n    async function protect(rules, ctx, request) {\n        // This goes against the type definition above, but users might call\n        // `protect()` with no value and we don't want to crash\n        if (typeof request === \"undefined\") {\n            request = {};\n        }\n        const details = Object.freeze({\n            ip: request.ip,\n            method: request.method,\n            protocol: request.protocol,\n            host: request.host,\n            path: request.path,\n            headers: new _arcjet_headers__WEBPACK_IMPORTED_MODULE_3__.ArcjetHeaders(request.headers),\n            cookies: request.cookies,\n            query: request.query,\n            extra: extraProps(request),\n            email: typeof request.email === \"string\" ? request.email : undefined,\n        });\n        const characteristics = options.characteristics\n            ? [...options.characteristics]\n            : [];\n        const waitUntil = lookupWaitUntil();\n        const baseContext = {\n            key,\n            log,\n            characteristics,\n            waitUntil,\n            ...ctx,\n        };\n        let fingerprint = \"\";\n        const logFingerprintPerf = perf.measure(\"fingerprint\");\n        try {\n            fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_1__.generateFingerprint(baseContext, toAnalyzeRequest(details));\n            log.debug(\"fingerprint (%s): %s\", rt, fingerprint);\n        }\n        catch (error) {\n            log.error({ error: errorMessage(error) }, \"Failed to build fingerprint. Please verify your Characteristics.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),\n                // No results because we couldn't create a fingerprint\n                results: [],\n            });\n            // TODO: Consider sending this to Report when we have an infallible fingerprint\n            return decision;\n        }\n        finally {\n            logFingerprintPerf();\n        }\n        const context = Object.freeze({\n            ...baseContext,\n            cache,\n            fingerprint,\n            runtime: rt,\n        });\n        if (rules.length < 1) {\n            log.warn(\"Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?\");\n        }\n        if (rules.length > 10) {\n            log.error(\"Failure running rules. Only 10 rules may be specified.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Only 10 rules may be specified\"),\n                // No results because the sorted rules were too long and we don't want\n                // to instantiate a ton of NOT_RUN results\n                results: [],\n            });\n            client.report(context, details, decision, \n            // No rules because we've determined they were too long and we don't\n            // want to try to send them to the server\n            []);\n            return decision;\n        }\n        const results = [];\n        for (let idx = 0; idx < rules.length; idx++) {\n            // Default all rules to NOT_RUN/ALLOW before doing anything\n            results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                // TODO(#4030): Figure out if we can get each Rule ID before they are run\n                ruleId: \"\",\n                fingerprint,\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason(),\n            });\n            // Add top-level characteristics to all Rate Limit rules that don't already have\n            // their own set of characteristics.\n            const candidate_rule = rules[idx];\n            if (isRateLimitRule(candidate_rule)) {\n                if (typeof candidate_rule.characteristics === \"undefined\") {\n                    candidate_rule.characteristics = characteristics;\n                    rules[idx] = candidate_rule;\n                }\n            }\n        }\n        const logLocalPerf = perf.measure(\"local\");\n        try {\n            for (const [idx, rule] of rules.entries()) {\n                // This re-assignment is a workaround to a TypeScript error with\n                // assertions where the name was introduced via a destructure\n                const localRule = rule;\n                const logRulePerf = perf.measure(rule.type);\n                try {\n                    if (typeof localRule.validate !== \"function\") {\n                        throw new Error(\"rule must have a `validate` function\");\n                    }\n                    localRule.validate(context, details);\n                    if (typeof localRule.protect !== \"function\") {\n                        throw new Error(\"rule must have a `protect` function\");\n                    }\n                    results[idx] = await localRule.protect(context, details);\n                    // If a rule didn't return a rule result, we need to stub it to avoid\n                    // crashing. This should only happen if a user writes a custom local\n                    // rule incorrectly.\n                    if (typeof results[idx] === \"undefined\") {\n                        results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                            // TODO(#4030): If we can get the Rule ID before running rules,\n                            // this can use it\n                            ruleId: \"\",\n                            fingerprint,\n                            ttl: 0,\n                            state: \"RUN\",\n                            conclusion: \"ERROR\",\n                            reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"rule result missing\"),\n                        });\n                    }\n                    log.debug({\n                        id: results[idx].ruleId,\n                        rule: rule.type,\n                        fingerprint,\n                        path: details.path,\n                        runtime: rt,\n                        ttl: results[idx].ttl,\n                        conclusion: results[idx].conclusion,\n                        reason: results[idx].reason,\n                    }, \"Local rule result:\");\n                }\n                catch (err) {\n                    log.error(\"Failure running rule: %s due to %s\", rule.type, errorMessage(err));\n                    results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        // TODO(#4030): Figure out if we can get a Rule ID in this error case\n                        ruleId: \"\",\n                        fingerprint,\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                    });\n                }\n                finally {\n                    logRulePerf();\n                }\n                const result = results[idx];\n                if (result.isDenied()) {\n                    // If the rule is not a DRY_RUN, we want to cache non-zero TTL results\n                    // and return a DENY decision.\n                    if (result.state !== \"DRY_RUN\") {\n                        const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                            ttl: result.ttl,\n                            reason: result.reason,\n                            results,\n                        });\n                        // Only a DENY decision is reported to avoid creating 2 entries for\n                        // a request. Upon ALLOW, the `decide` call will create an entry for\n                        // the request.\n                        client.report(context, details, decision, rules);\n                        if (result.ttl > 0) {\n                            log.debug({\n                                fingerprint: result.fingerprint,\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, \"Caching decision for %d seconds\", decision.ttl);\n                            cache.set(result.ruleId, result.fingerprint, {\n                                conclusion: result.conclusion,\n                                reason: result.reason,\n                            }, result.ttl);\n                        }\n                        return decision;\n                    }\n                    log.warn(`Dry run mode is enabled for \"%s\" rule. Overriding decision. Decision was: DENY`, rule.type);\n                }\n            }\n        }\n        finally {\n            logLocalPerf();\n        }\n        // With no cached values, we take a decision remotely. We use a timeout to\n        // fail open.\n        const logRemotePerf = perf.measure(\"remote\");\n        try {\n            const logDediceApiPerf = perf.measure(\"decideApi\");\n            const decision = await client\n                .decide(context, details, rules)\n                .finally(() => {\n                logDediceApiPerf();\n            });\n            // If the decision is to block and we have a non-zero TTL, we cache the\n            // block locally\n            if (decision.isDenied() && decision.ttl > 0) {\n                log.debug(\"decide: Caching block locally for %d seconds\", decision.ttl);\n                for (const result of decision.results) {\n                    // Cache all DENY results for local cache lookups\n                    if (result.conclusion === \"DENY\") {\n                        cache.set(result.ruleId, result.fingerprint, {\n                            conclusion: result.conclusion,\n                            reason: result.reason,\n                        }, result.ttl);\n                    }\n                }\n            }\n            return decision;\n        }\n        catch (err) {\n            log.info(\"Encountered problem getting remote decision: %s\", errorMessage(err));\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                results,\n            });\n            client.report(context, details, decision, rules);\n            return decision;\n        }\n        finally {\n            logRemotePerf();\n        }\n    }\n    // This is a separate function so it can be called recursively\n    function withRule(baseRules, rule) {\n        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);\n        return Object.freeze({\n            withRule(rule) {\n                return withRule(rules, rule);\n            },\n            async protect(ctx, request) {\n                return protect(rules, ctx, request);\n            },\n        });\n    }\n    return Object.freeze({\n        /**\n         * Augment the client with another rule.\n         *\n         * Useful for varying rules based on criteria in your handler such as\n         * different rate limit for logged in users.\n         *\n         * @param rule\n         *   Rule to add to Arcjet.\n         * @returns\n         *   Arcjet instance augmented with the given rule.\n         */\n        withRule(rule) {\n            return withRule(rootRules, rule);\n        },\n        /**\n         * Make a decision about how to handle a request.\n         *\n         * This will analyze the request locally where possible and otherwise call\n         * the Arcjet decision API.\n         *\n         * @param ctx\n         *   Additional context for this function call.\n         * @param request\n         *   Details about the {@linkcode ArcjetRequest} that Arcjet needs to make a\n         *   decision.\n         * @returns\n         *   Promise that resolves to an {@linkcode ArcjetDecision} indicating\n         *   Arcjet’s decision about the request.\n         */\n        async protect(ctx, request) {\n            return protect(rootRules, ctx, request);\n        },\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKG1pZGRsZXdhcmUpLy4vbm9kZV9tb2R1bGVzL2FyY2pldC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQytNO0FBQzNOO0FBQ1U7QUFDRTtBQUNHO0FBQ047QUFDSTtBQUNGOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSSxnQkFBZ0IsU0FBUztBQUNuRjtBQUNBO0FBQ0Esc0RBQXNELElBQUksdUJBQXVCLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksdUJB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QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUU4SSIsInNvdXJjZXMiOlsiQzpcXGdpdGh1Yl9jbG9uZVxcanAxOTg4Y2hpbGxcXG5leHRqcy1yZWFjdC10ZW1wbGF0ZVxcbXktYXBwXFxub2RlX21vZHVsZXNcXGFyY2pldFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgcHJvdG9jb2wgZnJvbSAnQGFyY2pldC9wcm90b2NvbCc7XG5pbXBvcnQgeyBBcmNqZXRFcnJvckRlY2lzaW9uLCBBcmNqZXRFcnJvclJlYXNvbiwgQXJjamV0UnVsZVJlc3VsdCwgQXJjamV0UmVhc29uLCBBcmNqZXREZW55RGVjaXNpb24sIEFyY2pldEJvdFJlYXNvbiwgQXJjamV0UmF0ZUxpbWl0UmVhc29uLCBBcmNqZXRFbWFpbFJlYXNvbiwgQXJjamV0U2hpZWxkUmVhc29uLCBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uLCBBcmNqZXRGaWx0ZXJSZWFzb24gfSBmcm9tICdAYXJjamV0L3Byb3RvY29sJztcbmV4cG9ydCAqIGZyb20gJ0BhcmNqZXQvcHJvdG9jb2wnO1xuaW1wb3J0ICogYXMgYW5hbHl6ZSBmcm9tICdAYXJjamV0L2FuYWx5emUnO1xuaW1wb3J0ICogYXMgZHVyYXRpb24gZnJvbSAnQGFyY2pldC9kdXJhdGlvbic7XG5pbXBvcnQgeyBBcmNqZXRIZWFkZXJzIH0gZnJvbSAnQGFyY2pldC9oZWFkZXJzJztcbmltcG9ydCB7IHJ1bnRpbWUgfSBmcm9tICdAYXJjamV0L3J1bnRpbWUnO1xuaW1wb3J0ICogYXMgaGFzaGVyIGZyb20gJ0BhcmNqZXQvc3RhYmxlLWhhc2gnO1xuaW1wb3J0IHsgTWVtb3J5Q2FjaGUgfSBmcm9tICdAYXJjamV0L2NhY2hlJztcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycikge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnIgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIFwibWVzc2FnZVwiIGluIGVyciAmJlxuICAgICAgICAgICAgdHlwZW9mIGVyci5tZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiVW5rbm93biBwcm9ibGVtXCI7XG59XG5jb25zdCBrbm93bkZpZWxkcyA9IFtcbiAgICBcImlwXCIsXG4gICAgXCJtZXRob2RcIixcbiAgICBcInByb3RvY29sXCIsXG4gICAgXCJob3N0XCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJoZWFkZXJzXCIsXG4gICAgXCJib2R5XCIsXG4gICAgXCJlbWFpbFwiLFxuICAgIFwiY29va2llc1wiLFxuICAgIFwicXVlcnlcIixcbl07XG5mdW5jdGlvbiBpc1Vua25vd25SZXF1ZXN0UHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuICFrbm93bkZpZWxkcy5pbmNsdWRlcyhrZXkpO1xufVxuZnVuY3Rpb24gaXNFbWFpbFR5cGUodHlwZSkge1xuICAgIHJldHVybiAodHlwZSA9PT0gXCJGUkVFXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJESVNQT1NBQkxFXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJOT19NWF9SRUNPUkRTXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJOT19HUkFWQVRBUlwiIHx8XG4gICAgICAgIHR5cGUgPT09IFwiSU5WQUxJRFwiKTtcbn1cbmNsYXNzIFBlcmZvcm1hbmNlIHtcbiAgICBsb2c7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgICAgIHRoaXMubG9nID0gbG9nZ2VyO1xuICAgIH1cbiAgICAvLyBUT0RPKCMyMDIwKTogV2Ugc2hvdWxkIG5vLW9wIHRoaXMgaWYgbG9nbGV2ZWwgaXMgbm90IGBkZWJ1Z2AgdG8gZG8gbGVzcyB3b3JrXG4gICAgbWVhc3VyZShsYWJlbCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcIkxBVEVOQ1kgJXM6ICVzbXNcIiwgbGFiZWwsIGRpZmYudG9GaXhlZCgzKSk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9YDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgfVxuICAgIHJldHVybiBcIjx1bnN1cHBvcnRlZCB2YWx1ZT5cIjtcbn1cbi8vIFRoaXMgaXMgdGhlIFN5bWJvbCB0aGF0IFZlcmNlbCBkZWZpbmVzIGluIHRoZWlyIGluZnJhc3RydWN0dXJlIHRvIGFjY2VzcyB0aGVcbi8vIENvbnRleHQgKHdoZXJlIGF2YWlsYWJsZSkuIFRoZSBDb250ZXh0IGNhbiBjb250YWluIHRoZSBgd2FpdFVudGlsYCBmdW5jdGlvbi5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvdmVyY2VsL2Jsb2IvOTMwZDdmYjg5MmRjMjZmMjQwZjJiOTUwZDk2MzkzMWM0NWUxZTY2MS9wYWNrYWdlcy9mdW5jdGlvbnMvc3JjL2dldC1jb250ZXh0LnRzI0w2XG5jb25zdCBTWU1CT0xfRk9SX1JFUV9DT05URVhUID0gU3ltYm9sLmZvcihcIkB2ZXJjZWwvcmVxdWVzdC1jb250ZXh0XCIpO1xuZnVuY3Rpb24gbG9va3VwV2FpdFVudGlsKCkge1xuICAgIGNvbnN0IGZyb21TeW1ib2wgPSBnbG9iYWxUaGlzO1xuICAgIGlmICh0eXBlb2YgZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdICE9PSBudWxsICYmXG4gICAgICAgIFwiZ2V0XCIgaW4gZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXSAmJlxuICAgICAgICB0eXBlb2YgZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXS5nZXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCB2ZXJjZWxDdHggPSBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdLmdldCgpO1xuICAgICAgICBpZiAodHlwZW9mIHZlcmNlbEN0eCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgdmVyY2VsQ3R4ICE9PSBudWxsICYmXG4gICAgICAgICAgICBcIndhaXRVbnRpbFwiIGluIHZlcmNlbEN0eCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZlcmNlbEN0eC53YWl0VW50aWwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZlcmNlbEN0eC53YWl0VW50aWw7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0b0FuYWx5emVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmhlYWRlcnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcmVxdWVzdC5oZWFkZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucmVxdWVzdCxcbiAgICAgICAgaGVhZGVycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gZXh0cmFQcm9wcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgZXh0cmEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGV0YWlscykpIHtcbiAgICAgICAgaWYgKGlzVW5rbm93blJlcXVlc3RQcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBleHRyYS5zZXQoa2V5LCB0b1N0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZXh0cmEuZW50cmllcygpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVWYWxpZGF0b3IoLi4udHlwZXMpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdHlwZU9mVmFsdWUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIGlmICghdHlwZXMuaW5jbHVkZXModHlwZU9mVmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkICR7dHlwZXNbMF19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgb25lIG9mICR7dHlwZXMuam9pbihcIiwgXCIpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbHVlVmFsaWRhdG9yKFxuLy8gVGhpcyB1c2VzIHR5cGVzIHRvIGVuc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDIgdmFsdWVzXG4uLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgLy8gV2UgY2FzdCB0aGUgdmFsdWVzIHRvIHVua25vd24gYmVjYXVzZSB0aGUgb3B0aW9uVmFsdWUgaXNuJ3Qga25vd24gYnV0XG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byB1c2UgYHZhbHVlc2Agb24gc3RyaW5nIGVudW1lcmF0aW9uc1xuICAgICAgICBpZiAoIXZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgb25lIG9mICR7dmFsdWVzLm1hcCgodmFsdWUpID0+IGAnJHt2YWx1ZX0nYCkuam9pbihcIiwgXCIpfWApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5VmFsaWRhdG9yKHZhbGlkYXRlKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBpdGVtXSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZShgJHtrZXl9WyR7aWR4fV1gLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBhbiBhcnJheWApO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcih7IHJ1bGUsIHZhbGlkYXRpb25zLCB9KSB7XG4gICAgcmV0dXJuIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIHZhbGlkYXRlLCByZXF1aXJlZCB9IG9mIHZhbGlkYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWQgJiYgIU9iamVjdC5oYXNPd24ob3B0aW9ucywga2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtydWxlfVxcYCBvcHRpb25zIGVycm9yOiBcXGAke2tleX1cXGAgaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgLy8gVGhlIGByZXF1aXJlZGAgZmxhZyBpcyBjaGVja2VkIGFib3ZlLCBzbyB0aGVzZSBzaG91bGQgb25seSBiZSB2YWxpZGF0ZWRcbiAgICAgICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgJHtydWxlfVxcYCBvcHRpb25zIGVycm9yOiAke2Vycm9yTWVzc2FnZShlcnIpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCB2YWxpZGF0ZVN0cmluZyA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJzdHJpbmdcIik7XG5jb25zdCB2YWxpZGF0ZU51bWJlciA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJudW1iZXJcIik7XG5jb25zdCB2YWxpZGF0ZUJvb2xlYW4gPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwiYm9vbGVhblwiKTtcbmNvbnN0IHZhbGlkYXRlRnVuY3Rpb24gPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwiZnVuY3Rpb25cIik7XG5jb25zdCB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcInN0cmluZ1wiLCBcIm51bWJlclwiKTtcbmNvbnN0IHZhbGlkYXRlU3RyaW5nQXJyYXkgPSBjcmVhdGVBcnJheVZhbGlkYXRvcih2YWxpZGF0ZVN0cmluZyk7XG5jb25zdCB2YWxpZGF0ZU1vZGUgPSBjcmVhdGVWYWx1ZVZhbGlkYXRvcihcIkxJVkVcIiwgXCJEUllfUlVOXCIpO1xuY29uc3QgdmFsaWRhdGVFbWFpbFR5cGVzID0gY3JlYXRlQXJyYXlWYWxpZGF0b3IoY3JlYXRlVmFsdWVWYWxpZGF0b3IoXCJESVNQT1NBQkxFXCIsIFwiRlJFRVwiLCBcIk5PX01YX1JFQ09SRFNcIiwgXCJOT19HUkFWQVRBUlwiLCBcIklOVkFMSURcIikpO1xuY29uc3QgdmFsaWRhdGVUb2tlbkJ1Y2tldE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwidG9rZW5CdWNrZXRcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibW9kZVwiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoYXJhY3RlcmlzdGljc1wiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcInJlZmlsbFJhdGVcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJpbnRlcnZhbFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiY2FwYWNpdHlcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlRml4ZWRXaW5kb3dPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImZpeGVkV2luZG93XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoYXJhY3RlcmlzdGljc1wiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcIm1heFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcIndpbmRvd1wiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNsaWRpbmdXaW5kb3dPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNsaWRpbmdXaW5kb3dcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwibWF4XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiaW50ZXJ2YWxcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTZW5zaXRpdmVJbmZvT3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJzZW5zaXRpdmVJbmZvXCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiY29udGV4dFdpbmRvd1NpemVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiZGV0ZWN0XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRnVuY3Rpb24gfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZUVtYWlsT3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJ2YWxpZGF0ZUVtYWlsXCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYmxvY2tcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRW1haWxUeXBlcyB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRW1haWxUeXBlcyB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicmVxdWlyZVRvcExldmVsRG9tYWluXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJhbGxvd0RvbWFpbkxpdGVyYWxcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVCb3RPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImRldGVjdEJvdFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiZGVueVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTaGllbGRPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNoaWVsZFwiLFxuICAgIHZhbGlkYXRpb25zOiBbeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfV0sXG59KTtcbi8qKlxuICogVmFsaWRhdGUgZmlsdGVyIG9wdGlvbnMuXG4gKi9cbmNvbnN0IHZhbGlkYXRlRmlsdGVyT3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJmaWx0ZXJcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJhbGxvd1wiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgICAgIHsga2V5OiBcImRlbnlcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgIF0sXG59KTtcbmNvbnN0IFByaW9yaXR5ID0ge1xuICAgIFNlbnNpdGl2ZUluZm86IDEsXG4gICAgRmlsdGVyOiAyLFxuICAgIFNoaWVsZDogMyxcbiAgICBSYXRlTGltaXQ6IDQsXG4gICAgQm90RGV0ZWN0aW9uOiA1LFxuICAgIEVtYWlsVmFsaWRhdGlvbjogNixcbn07XG5mdW5jdGlvbiBpc1JhdGVMaW1pdFJ1bGUocnVsZSkge1xuICAgIHJldHVybiBydWxlLnR5cGUgPT09IFwiUkFURV9MSU1JVFwiO1xufVxuLyoqXG4gKiBBcmNqZXQgdG9rZW4gYnVja2V0IHJhdGUgbGltaXRpbmcgcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgc2V0cyBhIHRva2VuIGJ1Y2tldCByYXRlIGxpbWl0LlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIGEgYnVja2V0IGZpbGxlZCB3aXRoIGEgc3BlY2lmaWMgbnVtYmVyIG9mIHRva2Vucy5cbiAqIEVhY2ggcmVxdWVzdCB3aXRoZHJhd3Mgc29tZSBhbW91bnQgb2YgdG9rZW5zIGZyb20gdGhlIGJ1Y2tldCBhbmQgdGhlIGJ1Y2tldFxuICogaXMgcmVmaWxsZWQgYXQgYSBmaXhlZCByYXRlLlxuICogT25jZSB0aGUgYnVja2V0IGlzIGVtcHR5LCB0aGUgY2xpZW50IGlzIGJsb2NrZWQgdW50aWwgdGhlIGJ1Y2tldCByZWZpbGxzLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGFsbG93IGNsaWVudHMgdG8gbWFrZSBhIGJ1cnN0IG9mXG4gKiByZXF1ZXN0cyBhbmQgdGhlbiBzdGlsbCBiZSBhYmxlIHRvIG1ha2UgcmVxdWVzdHMgYXQgYSBzbG93ZXIgcmF0ZS5cbiAqXG4gKiBAdGVtcGxhdGUgQ2hhcmFjdGVyaXN0aWNzXG4gKiAgIENoYXJhY3RlcmlzdGljcyB0byB0cmFjayBhIHVzZXIgYnkuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgdG9rZW4gYnVja2V0IHJhdGUgbGltaXRpbmcgcnVsZSAocmVxdWlyZWQpLlxuICogQHJldHVybnNcbiAqICAgVG9rZW4gYnVja2V0IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIHRva2VuQnVja2V0KHtcbiAqICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICByZWZpbGxSYXRlOiAxMCxcbiAqICAgICBpbnRlcnZhbDogXCI2MHNcIixcbiAqICAgICBjYXBhY2l0eTogMTAwLFxuICogICB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgICB0b2tlbkJ1Y2tldCh7XG4gKiAgICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgICByZWZpbGxSYXRlOiAxMCxcbiAqICAgICAgICAgaW50ZXJ2YWw6IFwiNjBzXCIsXG4gKiAgICAgICAgIGNhcGFjaXR5OiAxMDAsXG4gKiAgICAgICB9KSxcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9hbGdvcml0aG1zI3Rva2VuLWJ1Y2tldFxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gdG9rZW5CdWNrZXQob3B0aW9ucykge1xuICAgIHZhbGlkYXRlVG9rZW5CdWNrZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHR5cGUgPSBcIlJBVEVfTElNSVRcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gQXJyYXkuaXNBcnJheShvcHRpb25zLmNoYXJhY3RlcmlzdGljcylcbiAgICAgICAgPyBvcHRpb25zLmNoYXJhY3RlcmlzdGljc1xuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZWZpbGxSYXRlID0gb3B0aW9ucy5yZWZpbGxSYXRlO1xuICAgIGNvbnN0IGludGVydmFsID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBvcHRpb25zLmNhcGFjaXR5O1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5SYXRlTGltaXQsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgYWxnb3JpdGhtOiBcIlRPS0VOX0JVQ0tFVFwiLFxuICAgICAgICByZWZpbGxSYXRlLFxuICAgICAgICBpbnRlcnZhbCxcbiAgICAgICAgY2FwYWNpdHksXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQ2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzID8/IGNvbnRleHQuY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZyhcImFsZ29yaXRobVwiLCBcIlRPS0VOX0JVQ0tFVFwiKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImNoYXJhY3RlcmlzdGljc1wiLCBsb2NhbENoYXJhY3RlcmlzdGljcyksIFxuICAgICAgICAgICAgLy8gTWF0Y2ggaXMgZGVwcmVjYXRlZCBzbyBpdCBpcyBhbHdheXMgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXdlc3QgU0RLc1xuICAgICAgICAgICAgaGFzaGVyLnN0cmluZyhcIm1hdGNoXCIsIFwiXCIpLCBoYXNoZXIudWludDMyKFwicmVmaWxsUmF0ZVwiLCByZWZpbGxSYXRlKSwgaGFzaGVyLnVpbnQzMihcImludGVydmFsXCIsIGludGVydmFsKSwgaGFzaGVyLnVpbnQzMihcImNhcGFjaXR5XCIsIGNhcGFjaXR5KSk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXplQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IGxvY2FsQ2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgICAgIGxvZzogY29udGV4dC5sb2csXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYW5hbHl6ZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQucmVhc29uLmlzUmF0ZUxpbWl0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIkNBQ0hFRFwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBjYWNoZWQuY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVidWlsZCB0aGUgYEFyY2pldFJhdGVMaW1pdFJlYXNvbmAgYmVjYXVzZSB3ZSBuZWVkIHRvIGFkanVzdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlc2V0YCBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lLXRvLWxpdmVcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogY2FjaGVkLnJlYXNvbi5tYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IGNhY2hlZC5yZWFzb24ucmVtYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IHR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogY2FjaGVkLnJlYXNvbi53aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFRpbWU6IGNhY2hlZC5yZWFzb24ucmVzZXRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJhdGVMaW1pdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNldFRpbWU6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBmaXhlZCB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBzZXRzIGEgZml4ZWQgd2luZG93IHJhdGUgbGltaXQgd2hpY2ggdHJhY2tzIHRoZSBudW1iZXIgb2ZcbiAqIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgb3ZlciBhIGZpeGVkIHRpbWUgd2luZG93LlxuICpcbiAqIFRoaXMgaXMgdGhlIHNpbXBsZXN0IGFsZ29yaXRobS5cbiAqIEl0IHRyYWNrcyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgb3ZlciBhIGZpeGVkIHRpbWUgd2luZG93XG4gKiBzdWNoIGFzIDYwIHNlY29uZHMuXG4gKiBJZiB0aGUgY2xpZW50IGV4Y2VlZHMgdGhlIGxpbWl0LCB0aGV5IGFyZSBibG9ja2VkIHVudGlsIHRoZSB3aW5kb3cgZXhwaXJlcy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBhcHBseSBhIHNpbXBsZSBmaXhlZCBsaW1pdCBpbiBhXG4gKiBmaXhlZCB0aW1lIHdpbmRvdy5cbiAqIEZvciBleGFtcGxlLCBhIHNpbXBsZSBsaW1pdCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mIHJlcXVlc3RzIGEgY2xpZW50IGNhbiBtYWtlLlxuICogSG93ZXZlciwgaXQgY2FuIGJlIHN1c2NlcHRpYmxlIHRvIHRoZSBzdGFtcGVkZSBwcm9ibGVtIHdoZXJlIGEgY2xpZW50IG1ha2VzXG4gKiBhIGJ1cnN0IG9mIHJlcXVlc3RzIGF0IHRoZSBzdGFydCBvZiBhIHdpbmRvdyBhbmQgdGhlbiBpcyBibG9ja2VkIGZvciB0aGUgcmVzdFxuICogb2YgdGhlIHdpbmRvdy5cbiAqIFRoZSBzbGlkaW5nIHdpbmRvdyBhbGdvcml0aG0gY2FuIGJlIHVzZWQgdG8gYXZvaWQgdGhpcy5cbiAqXG4gKiBAdGVtcGxhdGUgQ2hhcmFjdGVyaXN0aWNzXG4gKiAgIENoYXJhY3RlcmlzdGljcyB0byB0cmFjayBhIHVzZXIgYnkuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgZml4ZWQgd2luZG93IHJhdGUgbGltaXRpbmcgcnVsZSAocmVxdWlyZWQpLlxuICogQHJldHVybnNcbiAqICAgRml4ZWQgd2luZG93IHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgIGZpZWxkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGZpeGVkV2luZG93KHsgbW9kZTogXCJMSVZFXCIsIHdpbmRvdzogXCI2MHNcIiwgbWF4OiAxMDAgfSk7XG4gKiAgIGBgYFxuICogQGV4YW1wbGVcbiAqICAgYGBgdHNcbiAqICAgY29uc3QgYWogPSBhcmNqZXQoe1xuICogICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIGZpeGVkV2luZG93KHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIHdpbmRvdzogXCI2MHNcIixcbiAqICAgICAgICAgbWF4OiAxMDAsXG4gKiAgICAgICB9KVxuICogICAgIF0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjZml4ZWQtd2luZG93XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBmaXhlZFdpbmRvdyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVGaXhlZFdpbmRvd09wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4O1xuICAgIGNvbnN0IHdpbmRvdyA9IGR1cmF0aW9uLnBhcnNlKG9wdGlvbnMud2luZG93KTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuUmF0ZUxpbWl0LFxuICAgICAgICBtb2RlLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGFsZ29yaXRobTogXCJGSVhFRF9XSU5ET1dcIixcbiAgICAgICAgbWF4LFxuICAgICAgICB3aW5kb3csXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQ2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzID8/IGNvbnRleHQuY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZyhcImFsZ29yaXRobVwiLCBcIkZJWEVEX1dJTkRPV1wiKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImNoYXJhY3RlcmlzdGljc1wiLCBsb2NhbENoYXJhY3RlcmlzdGljcyksIFxuICAgICAgICAgICAgLy8gTWF0Y2ggaXMgZGVwcmVjYXRlZCBzbyBpdCBpcyBhbHdheXMgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXdlc3QgU0RLc1xuICAgICAgICAgICAgaGFzaGVyLnN0cmluZyhcIm1hdGNoXCIsIFwiXCIpLCBoYXNoZXIudWludDMyKFwibWF4XCIsIG1heCksIGhhc2hlci51aW50MzIoXCJ3aW5kb3dcIiwgd2luZG93KSk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXplQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IGxvY2FsQ2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgICAgIGxvZzogY29udGV4dC5sb2csXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYW5hbHl6ZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCAmJiBjYWNoZWQucmVhc29uLmlzUmF0ZUxpbWl0KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIkNBQ0hFRFwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBjYWNoZWQuY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVidWlsZCB0aGUgYEFyY2pldFJhdGVMaW1pdFJlYXNvbmAgYmVjYXVzZSB3ZSBuZWVkIHRvIGFkanVzdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgYHJlc2V0YCBiYXNlZCBvbiB0aGUgY3VycmVudCB0aW1lLXRvLWxpdmVcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmF0ZUxpbWl0UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogY2FjaGVkLnJlYXNvbi5tYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmc6IGNhY2hlZC5yZWFzb24ucmVtYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IHR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdzogY2FjaGVkLnJlYXNvbi53aW5kb3csXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFRpbWU6IGNhY2hlZC5yZWFzb24ucmVzZXRUaW1lLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJOT1RfUlVOXCIsXG4gICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJhdGVMaW1pdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgIG1heDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByZXNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiAwLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgc2xpZGluZyB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBzZXRzIGEgc2xpZGluZyB3aW5kb3cgcmF0ZSBsaW1pdCB3aGljaCB0cmFja3MgdGhlIG51bWJlclxuICogb2YgcmVxdWVzdHMgbWFkZSBieSBhIGNsaWVudCBvdmVyIGEgc2xpZGluZyB3aW5kb3cgc28gdGhhdCB0aGUgd2luZG93IG1vdmVzXG4gKiB3aXRoIHRpbWUuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgdXNlZnVsIHRvIGF2b2lkIHRoZSBzdGFtcGVkZSBwcm9ibGVtIG9mIHRoZSBmaXhlZCB3aW5kb3cuXG4gKiBJdCBwcm92aWRlcyBzbW9vdGhlciByYXRlIGxpbWl0aW5nIG92ZXIgdGltZSBhbmQgY2FuIHByZXZlbnQgYSBjbGllbnQgZnJvbVxuICogbWFraW5nIGEgYnVyc3Qgb2YgcmVxdWVzdHMgYXQgdGhlIHN0YXJ0IG9mIGEgd2luZG93IGFuZCB0aGVuIGJlaW5nIGJsb2NrZWRcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgd2luZG93LlxuICpcbiAqIEB0ZW1wbGF0ZSBDaGFyYWN0ZXJpc3RpY3NcbiAqICAgQ2hhcmFjdGVyaXN0aWNzIHRvIHRyYWNrIGEgdXNlciBieS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBzbGlkaW5nIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUgKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zXG4gKiAgIFRva2VuIGJ1Y2tldCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBzbGlkaW5nV2luZG93KHsgbW9kZTogXCJMSVZFXCIsIGludGVydmFsOiBcIjYwc1wiLCBtYXg6IDEwMCB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgICBzbGlkaW5nV2luZG93KHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIGludGVydmFsOiBcIjYwc1wiLFxuICogICAgICAgICBtYXg6IDEwMCxcbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvYWxnb3JpdGhtcyNzbGlkaW5nLXdpbmRvd1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vcmF0ZS1saW1pdGluZy9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2xpZGluZ1dpbmRvdyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTbGlkaW5nV2luZG93T3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB0eXBlID0gXCJSQVRFX0xJTUlUXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3MpXG4gICAgICAgID8gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbWF4ID0gb3B0aW9ucy5tYXg7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBkdXJhdGlvbi5wYXJzZShvcHRpb25zLmludGVydmFsKTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuUmF0ZUxpbWl0LFxuICAgICAgICBtb2RlLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGFsZ29yaXRobTogXCJTTElESU5HX1dJTkRPV1wiLFxuICAgICAgICBtYXgsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICB2YWxpZGF0ZSgpIHsgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbENoYXJhY3RlcmlzdGljcyA9IGNoYXJhY3RlcmlzdGljcyA/PyBjb250ZXh0LmNoYXJhY3RlcmlzdGljcztcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmcoXCJhbGdvcml0aG1cIiwgXCJTTElESU5HX1dJTkRPV1wiKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImNoYXJhY3RlcmlzdGljc1wiLCBsb2NhbENoYXJhY3RlcmlzdGljcyksIFxuICAgICAgICAgICAgLy8gTWF0Y2ggaXMgZGVwcmVjYXRlZCBzbyBpdCBpcyBhbHdheXMgYW4gZW1wdHkgc3RyaW5nIGluIHRoZSBuZXdlc3QgU0RLc1xuICAgICAgICAgICAgaGFzaGVyLnN0cmluZyhcIm1hdGNoXCIsIFwiXCIpLCBoYXNoZXIudWludDMyKFwibWF4XCIsIG1heCksIGhhc2hlci51aW50MzIoXCJpbnRlcnZhbFwiLCBpbnRlcnZhbCkpO1xuICAgICAgICAgICAgY29uc3QgYW5hbHl6ZUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBsb2NhbENoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICAgICAgICBsb2c6IGNvbnRleHQubG9nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmdlcnByaW50ID0gYXdhaXQgYW5hbHl6ZS5nZW5lcmF0ZUZpbmdlcnByaW50KGFuYWx5emVDb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KGRldGFpbHMpKTtcbiAgICAgICAgICAgIGNvbnN0IFtjYWNoZWQsIHR0bF0gPSBhd2FpdCBjb250ZXh0LmNhY2hlLmdldChydWxlSWQsIGZpbmdlcnByaW50KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLnJlYXNvbi5pc1JhdGVMaW1pdCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJDQUNIRURcIixcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogY2FjaGVkLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHJlYnVpbGQgdGhlIGBBcmNqZXRSYXRlTGltaXRSZWFzb25gIGJlY2F1c2Ugd2UgbmVlZCB0byBhZGp1c3RcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGByZXNldGAgYmFzZWQgb24gdGhlIGN1cnJlbnQgdGltZS10by1saXZlXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldFJhdGVMaW1pdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXg6IGNhY2hlZC5yZWFzb24ubWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nOiBjYWNoZWQucmVhc29uLnJlbWFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0OiB0dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IGNhY2hlZC5yZWFzb24ud2luZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRUaW1lOiBjYWNoZWQucmVhc29uLnJlc2V0VGltZSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSYXRlTGltaXRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBtYXg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZzogMCxcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdzogMCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbmZ1bmN0aW9uIHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKGVudGl0eSkge1xuICAgIGlmICh0eXBlb2YgZW50aXR5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW50aXR5IHR5cGVcIik7XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiRU1BSUxcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiZW1haWxcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIlBIT05FX05VTUJFUlwiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJwaG9uZS1udW1iZXJcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIklQX0FERFJFU1NcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiaXAtYWRkcmVzc1wiIH07XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiQ1JFRElUX0NBUkRfTlVNQkVSXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImNyZWRpdC1jYXJkLW51bWJlclwiIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogXCJjdXN0b21cIixcbiAgICAgICAgdmFsOiBlbnRpdHksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFuYWx5emVTZW5zaXRpdmVJbmZvRW50aXRpZXNUb1N0cmluZyhlbnRpdHkpIHtcbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgIHJldHVybiBcIkVNQUlMXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImlwLWFkZHJlc3NcIikge1xuICAgICAgICByZXR1cm4gXCJJUF9BRERSRVNTXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImNyZWRpdC1jYXJkLW51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIkNSRURJVF9DQVJEX05VTUJFUlwiO1xuICAgIH1cbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJwaG9uZS1udW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJQSE9ORV9OVU1CRVJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eS52YWw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShkZXRlY3RlZEVudGl0aWVzKSB7XG4gICAgcmV0dXJuIGRldGVjdGVkRW50aXRpZXMubWFwKChkZXRlY3RlZEVudGl0eSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGV0ZWN0ZWRFbnRpdHksXG4gICAgICAgICAgICBpZGVudGlmaWVkVHlwZTogYW5hbHl6ZVNlbnNpdGl2ZUluZm9FbnRpdGllc1RvU3RyaW5nKGRldGVjdGVkRW50aXR5LmlkZW50aWZpZWRUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogQXJjamV0IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBkZXRlY3Rpb24gcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgcHJvdGVjdHMgYWdhaW5zdCBjbGllbnRzIHNlbmRpbmcgeW91IHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICogc3VjaCBhcyBwZXJzb25hbGx5IGlkZW50aWZpYWJsZSBpbmZvcm1hdGlvbiAoUElJKSB0aGF0IHlvdSBkbyBub3Qgd2lzaCB0b1xuICogaGFuZGxlLlxuICogVGhlIHJ1bGUgcnVucyBlbnRpcmVseSBsb2NhbGx5IHNvIG5vIGRhdGEgZXZlciBsZWF2ZXMgeW91ciBlbnZpcm9ubWVudC5cbiAqXG4gKiBUaGlzIHJ1bGUgaW5jbHVkZXMgYnVpbHQtaW4gZGV0ZWN0aW9ucyBmb3IgZW1haWwgYWRkcmVzc2VzLCBjcmVkaXQvZGViaXQgY2FyZFxuICogbnVtYmVycywgSVAgYWRkcmVzc2VzLCBhbmQgcGhvbmUgbnVtYmVycy5cbiAqIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY3VzdG9tIGRldGVjdGlvbiBmdW5jdGlvbiB0byBpZGVudGlmeSBhZGRpdGlvbmFsXG4gKiBzZW5zaXRpdmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHRlbXBsYXRlIERldGVjdFxuICogICBDdXN0b20gZGV0ZWN0aW9uIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi5cbiAqIEB0ZW1wbGF0ZSBDdXN0b21FbnRpdGllc1xuICogICBDdXN0b20gZW50aXRpZXMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgc2Vuc2l0aXZlIGluZm9ybWF0aW9uIGRldGVjdGlvbiBydWxlIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJuc1xuICogICBTZW5zaXRpdmUgaW5mb3JtYXRpb24gcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlIGBydWxlc2AgZmllbGQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgYGBgdHNcbiAqICAgc2Vuc2l0aXZlSW5mbyh7IG1vZGU6IFwiTElWRVwiLCBkZW55OiBbXCJFTUFJTFwiXSB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgICBzZW5zaXRpdmVJbmZvKHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIGRlbnk6IFtcIkVNQUlMXCJdLFxuICogICAgICAgfSlcbiAqICAgICBdLFxuICogICB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBDdXN0b20gZGV0ZWN0aW9uIGZ1bmN0aW9uOlxuICpcbiAqICAgYGBgdHNcbiAqICAgZnVuY3Rpb24gZGV0ZWN0RGFzaCh0b2tlbnM6IHN0cmluZ1tdKTogQXJyYXk8XCJDT05UQUlOU19EQVNIXCIgfCB1bmRlZmluZWQ+IHtcbiAqICAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAqICAgICAgIGlmICh0b2tlbi5pbmNsdWRlcyhcIi1cIikpIHtcbiAqICAgICAgICAgcmV0dXJuIFwiQ09OVEFJTlNfREFTSFwiO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICogICB9XG4gKlxuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgICBzZW5zaXRpdmVJbmZvKHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIGRlbnk6IFtcIkVNQUlMXCIsIFwiQ09OVEFJTlNfREFTSFwiXSxcbiAqICAgICAgICAgZGV0ZWN0OiBkZXRlY3REYXNoLFxuICogICAgICAgICBjb250ZXh0V2luZG93U2l6ZTogMixcbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NlbnNpdGl2ZS1pbmZvL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zZW5zaXRpdmUtaW5mby9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gc2Vuc2l0aXZlSW5mbyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTZW5zaXRpdmVJbmZvT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc2Vuc2l0aXZlSW5mb2Agb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGRlbnlgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHNlbnNpdGl2ZUluZm9gIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiU0VOU0lUSVZFX0lORk9cIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93IHx8IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgfHwgW107XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlNlbnNpdGl2ZUluZm8sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGFsbG93LFxuICAgICAgICBkZW55LFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7IH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSkpO1xuICAgICAgICAgICAgY29uc3QgeyBmaW5nZXJwcmludCB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIC8vIE5vIGNhY2hlIGlzIGltcGxlbWVudGVkIGhlcmUgYmVjYXVzZSB0aGUgZmluZ2VycHJpbnQgY2FuIGJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyB3aGlsZSB0aGUgcmVxdWVzdCBib2R5IGNoYW5nZXMuIFRoaXMgaXMgYWxzbyB3aHkgdGhlIGBzZW5zaXRpdmVJbmZvYFxuICAgICAgICAgICAgLy8gcnVsZSByZXN1bHRzIGFsd2F5cyBoYXZlIGEgYHR0bGAgb2YgMC5cbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBjb250ZXh0LmdldEJvZHkoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiQ291bGRuJ3QgcmVhZCB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdCB0byBwZXJmb3JtIHNlbnNpdGl2ZSBpbmZvIGlkZW50aWZpY2F0aW9uLlwiKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb252ZXJ0ZWREZXRlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGV0ZWN0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGV0ZWN0ID0gb3B0aW9ucy5kZXRlY3Q7XG4gICAgICAgICAgICAgICAgY29udmVydGVkRGV0ZWN0ID0gKHRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV0ZWN0KHRva2VucylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IHR5cGVvZiBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgIGxldCBlbnRpdGllc1ZhbCA9IFtdO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGxvdykpIHtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1ZhbCA9IG9wdGlvbnMuYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5kZW55KSkge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzVGFnID0gXCJkZW55XCI7XG4gICAgICAgICAgICAgICAgZW50aXRpZXNWYWwgPSBvcHRpb25zLmRlbnlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW50aXRpZXMgPSB7XG4gICAgICAgICAgICAgICAgdGFnOiBlbnRpdGllc1RhZyxcbiAgICAgICAgICAgICAgICB2YWw6IGVudGl0aWVzVmFsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emUuZGV0ZWN0U2Vuc2l0aXZlSW5mbyhjb250ZXh0LCBib2R5LCBlbnRpdGllcywgb3B0aW9ucy5jb250ZXh0V2luZG93U2l6ZSB8fCAxLCBjb252ZXJ0ZWREZXRlY3QpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uKHtcbiAgICAgICAgICAgICAgICBkZW5pZWQ6IGNvbnZlcnRBbmFseXplRGV0ZWN0ZWRTZW5zaXRpdmVJbmZvRW50aXR5KHJlc3VsdC5kZW5pZWQpLFxuICAgICAgICAgICAgICAgIGFsbG93ZWQ6IGNvbnZlcnRBbmFseXplRGV0ZWN0ZWRTZW5zaXRpdmVJbmZvRW50aXR5KHJlc3VsdC5hbGxvd2VkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZW5pZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IGVtYWlsIHZhbGlkYXRpb24gcnVsZS5cbiAqXG4gKiBBcHBseWluZyB0aGlzIHJ1bGUgYWxsb3dzIHlvdSB0byB2YWxpZGF0ZSBhbmQgdmVyaWZ5IGFuIGVtYWlsIGFkZHJlc3MuXG4gKlxuICogVGhlIGZpcnN0IHN0ZXAgb2YgdGhlIGFuYWx5c2lzIGlzIHRvIHZhbGlkYXRlIHRoZSBlbWFpbCBhZGRyZXNzIHN5bnRheC5cbiAqIFRoaXMgcnVucyBsb2NhbGx5IHdpdGhpbiB0aGUgU0RLIGFuZCB2YWxpZGF0ZXMgdGhlIGVtYWlsIGFkZHJlc3MgaXMgaW4gdGhlXG4gKiBjb3JyZWN0IGZvcm1hdC5cbiAqIElmIHRoZSBlbWFpbCBzeW50YXggaXMgdmFsaWQsIHRoZSBTREsgd2lsbCBwYXNzIHRoZSBlbWFpbCBhZGRyZXNzIHRvIHRoZVxuICogQXJjamV0IGNsb3VkIEFQSSB0byB2ZXJpZnkgdGhlIGVtYWlsIGFkZHJlc3MuXG4gKiBUaGlzIHBlcmZvcm1zIHNldmVyYWwgY2hlY2tzLCBkZXBlbmRpbmcgb24gdGhlIHJ1bGUgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgZW1haWwgdmFsaWRhdGlvbiBydWxlIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJuc1xuICogICBFbWFpbCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICB2YWxpZGF0ZUVtYWlsKHsgbW9kZTogXCJMSVZFXCIsIGRlbnk6IFtcIkRJU1BPU0FCTEVcIiwgXCJJTlZBTElEXCJdIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIHZhbGlkYXRlRW1haWwoe1xuICogICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgZGVueTogW1wiRElTUE9TQUJMRVwiLCBcIklOVkFMSURcIl1cbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICpcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2VtYWlsLXZhbGlkYXRpb24vY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2VtYWlsLXZhbGlkYXRpb24vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRW1haWwob3B0aW9ucykge1xuICAgIHZhbGlkYXRlRW1haWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBgYWxsb3dgIGFuZCBgZGVueWAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmxvY2sgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBibG9ja2AgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdmFsaWRhdGVFbWFpbGAgb3B0aW9ucyBlcnJvcjogYGRlbnlgIGFuZCBgYmxvY2tgIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlciwgYGJsb2NrYCBpcyBub3cgZGVwcmVjYXRlZCBzbyBgZGVueWAgc2hvdWxkIGJlIHByZWZlcnJlZC5cIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJsb2NrID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBcIkVNQUlMXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy5hbGxvdyA/PyBbXTtcbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy5kZW55ID8/IG9wdGlvbnMuYmxvY2sgPz8gW107XG4gICAgY29uc3QgcmVxdWlyZVRvcExldmVsRG9tYWluID0gb3B0aW9ucy5yZXF1aXJlVG9wTGV2ZWxEb21haW4gPz8gdHJ1ZTtcbiAgICBjb25zdCBhbGxvd0RvbWFpbkxpdGVyYWwgPSBvcHRpb25zLmFsbG93RG9tYWluTGl0ZXJhbCA/PyBmYWxzZTtcbiAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICB0YWc6IFwiZGVueS1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgIGRlbnk6IFtdLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJhbGxvdy1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5hbGxvdyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGRlbnk6IG9wdGlvbnMuZGVueSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICB0YWc6IFwiZGVueS1lbWFpbC12YWxpZGF0aW9uLWNvbmZpZ1wiLFxuICAgICAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgICAgIGFsbG93RG9tYWluTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBkZW55OiBvcHRpb25zLmJsb2NrLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LkVtYWlsVmFsaWRhdGlvbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIGRldGFpbHMuZW1haWwgIT09IFwidW5kZWZpbmVkXCIsIFwiVmFsaWRhdGVFbWFpbCByZXF1aXJlcyBgZW1haWxgIHRvIGJlIHNldC5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgeyBlbWFpbCB9KSB7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiYWxsb3dcIiwgYWxsb3cpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiZGVueVwiLCBkZW55KSwgaGFzaGVyLmJvb2woXCJyZXF1aXJlVG9wTGV2ZWxEb21haW5cIiwgcmVxdWlyZVRvcExldmVsRG9tYWluKSwgaGFzaGVyLmJvb2woXCJhbGxvd0RvbWFpbkxpdGVyYWxcIiwgYWxsb3dEb21haW5MaXRlcmFsKSk7XG4gICAgICAgICAgICBjb25zdCB7IGZpbmdlcnByaW50IH0gPSBjb250ZXh0O1xuICAgICAgICAgICAgLy8gTm8gY2FjaGUgaXMgaW1wbGVtZW50ZWQgaGVyZSBiZWNhdXNlIHRoZSBmaW5nZXJwcmludCBjYW4gYmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBlbWFpbCBjaGFuZ2VzLiBUaGlzIGlzIGFsc28gd2h5IHRoZSBgZW1haWxgIHJ1bGUgcmVzdWx0c1xuICAgICAgICAgICAgLy8gYWx3YXlzIGhhdmUgYSBgdHRsYCBvZiAwLlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5pc1ZhbGlkRW1haWwoY29udGV4dCwgZW1haWwsIGNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IG1vZGUgPT09IFwiTElWRVwiID8gXCJSVU5cIiA6IFwiRFJZX1JVTlwiO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZGl0eSA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFbWFpbFJlYXNvbih7IGVtYWlsVHlwZXM6IFtdIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRFbWFpbFR5cGVzID0gcmVzdWx0LmJsb2NrZWQuZmlsdGVyKGlzRW1haWxUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RW1haWxSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxUeXBlczogdHlwZWRFbWFpbFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBib3QgZGV0ZWN0aW9uIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIGFsbG93cyB5b3UgdG8gbWFuYWdlIHRyYWZmaWMgYnkgYXV0b21hdGVkIGNsaWVudHMgYW5kXG4gKiBib3RzLlxuICpcbiAqIEJvdHMgY2FuIGJlIGdvb2QgKHN1Y2ggYXMgc2VhcmNoIGVuZ2luZSBjcmF3bGVycyBvciBtb25pdG9yaW5nIGFnZW50cykgb3IgYmFkXG4gKiAoc3VjaCBhcyBzY3JhcGVycyBvciBhdXRvbWF0ZWQgc2NyaXB0cykuXG4gKiBBcmNqZXQgYWxsb3dzIHlvdSB0byBjb25maWd1cmUgd2hpY2ggYm90cyB5b3Ugd2FudCB0byBhbGxvdyBvciBkZW55IGJ5XG4gKiBzcGVjaWZpYyBib3QgbmFtZXMgc3VjaCBhcyBjdXJsLCBhcyB3ZWxsIGFzIGJ5IGNhdGVnb3J5IHN1Y2ggYXMgc2VhcmNoXG4gKiBlbmdpbmUgYm90cy5cbiAqXG4gKiBCb3RzIGFyZSBkZXRlY3RlZCBiYXNlZCBvbiB2YXJpb3VzIHNpZ25hbHMgc3VjaCBhcyB0aGUgdXNlciBhZ2VudCwgSVBcbiAqIGFkZHJlc3MsIEROUyByZWNvcmRzLCBhbmQgbW9yZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIGZvciB0aGUgYm90IHJ1bGUgKHJlcXVpcmVkKS5cbiAqIEByZXR1cm5zXG4gKiAgIEJvdCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBBbGxvdyBzZWFyY2ggZW5naW5lIGJvdHMgYW5kIGN1cmwsIGRlbnkgYWxsIG90aGVyIGJvdHM6XG4gKlxuICogICBgYGB0c1xuICogICBkZXRlY3RCb3QoeyBtb2RlOiBcIkxJVkVcIiwgYWxsb3c6IFtcIkNBVEVHT1JZOlNFQVJDSF9FTkdJTkVcIiwgXCJDVVJMXCJdIH0pO1xuICogICBgYGBcbiAqIEBleGFtcGxlXG4gKiAgIEFsbG93IHNlYXJjaCBlbmdpbmUgYm90cyBhbmQgY3VybCwgZGVueSBhbGwgb3RoZXIgYm90czpcbiAqXG4gKiAgIGBgYHRzXG4gKiAgIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAgICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgICAgcnVsZXM6IFtcbiAqICAgICAgIGRldGVjdEJvdCh7XG4gKiAgICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgICBhbGxvdzogW1wiQ0FURUdPUlk6U0VBUkNIX0VOR0lORVwiLCBcIkNVUkxcIl1cbiAqICAgICAgIH0pXG4gKiAgICAgXSxcbiAqICAgfSk7XG4gKiAgIGBgYFxuICogQGV4YW1wbGVcbiAqICAgRGVueSBBSSBjcmF3bGVycywgYWxsb3cgYWxsIG90aGVyIGJvdHM6XG4gKlxuICogICBgYGB0c1xuICogICBkZXRlY3RCb3QoeyBtb2RlOiBcIkxJVkVcIiwgZGVueTogW1wiQ0FURUdPUlk6QUlcIl0gfSk7XG4gKiAgIGBgYFxuICogQGV4YW1wbGVcbiAqICAgRGVueSBBSSBjcmF3bGVycywgYWxsb3dzIGFsbCBvdGhlciBib3RzOlxuICpcbiAqICAgYGBgdHNcbiAqICAgY29uc3QgYWogPSBhcmNqZXQoe1xuICogICAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgICBydWxlczogW1xuICogICAgICAgZGV0ZWN0Qm90KHtcbiAqICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgIGRlbnk6IFtcIkNBVEVHT1JZOkFJXCJdXG4gKiAgICAgICB9KVxuICogICAgIF0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vYm90LXByb3RlY3Rpb24vaWRlbnRpZnlpbmctYm90c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vYm90LXByb3RlY3Rpb24vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJvdChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVCb3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkZXRlY3RCb3RgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBkZW55YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkZXRlY3RCb3RgIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiQk9UXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy5hbGxvdyA/PyBbXTtcbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy5kZW55ID8/IFtdO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICBlbnRpdGllczogW10sXG4gICAgICAgICAgICBza2lwQ3VzdG9tRGV0ZWN0OiB0cnVlLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmFsbG93LFxuICAgICAgICAgICAgICAgIHNraXBDdXN0b21EZXRlY3Q6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICB0YWc6IFwiZGVuaWVkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmRlbnksXG4gICAgICAgICAgICAgICAgc2tpcEN1c3RvbURldGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5Cb3REZXRlY3Rpb24sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGFsbG93LFxuICAgICAgICBkZW55LFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRldGFpbHMuaGVhZGVycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdCBkZXRlY3Rpb24gcmVxdWlyZXMgYGhlYWRlcnNgIHRvIGJlIHNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlscy5oZWFkZXJzLmhhcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm90IGRldGVjdGlvbiByZXF1aXJlcyBgaGVhZGVyc2AgdG8gZXh0ZW5kIGBIZWFkZXJzYFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGV0YWlscy5oZWFkZXJzLmhhcyhcInVzZXItYWdlbnRcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3QgZGV0ZWN0aW9uIHJlcXVpcmVzIHVzZXItYWdlbnQgaGVhZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gY2FsbCB0aGUgYm90IGRldGVjdGlvbiBvbiB0aGUgaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSkpO1xuICAgICAgICAgICAgY29uc3QgeyBmaW5nZXJwcmludCB9ID0gY29udGV4dDtcbiAgICAgICAgICAgIGNvbnN0IFtjYWNoZWQsIHR0bF0gPSBhd2FpdCBjb250ZXh0LmNhY2hlLmdldChydWxlSWQsIGZpbmdlcnByaW50KTtcbiAgICAgICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIkNBQ0hFRFwiLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBjYWNoZWQuY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBjYWNoZWQucmVhc29uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5kZXRlY3RCb3QoY29udGV4dCwgdG9BbmFseXplUmVxdWVzdChyZXF1ZXN0KSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gbW9kZSA9PT0gXCJMSVZFXCIgPyBcIlJVTlwiIDogXCJEUllfUlVOXCI7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgYm90IGFuZCBvZiBhIHR5cGUgdGhhdCB3ZSB3YW50IHRvIGJsb2NrLCB0aGVuIGJsb2NrIVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kZW5pZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogNjAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0Qm90UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWQ6IHJlc3VsdC5hbGxvd2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuaWVkOiByZXN1bHQuZGVuaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IHJlc3VsdC52ZXJpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwb29mZWQ6IHJlc3VsdC5zcG9vZmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0Qm90UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWQ6IHJlc3VsdC5hbGxvd2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuaWVkOiByZXN1bHQuZGVuaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IHJlc3VsdC52ZXJpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwb29mZWQ6IHJlc3VsdC5zcG9vZmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBTaGllbGQgV0FGIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIHByb3RlY3RzIHlvdXIgYXBwbGljYXRpb24gYWdhaW5zdCBjb21tb24gYXR0YWNrcyxcbiAqIGluY2x1ZGluZyB0aGUgT1dBU1AgVG9wIDEwLlxuICpcbiAqIFRoZSBBcmNqZXQgU2hpZWxkIFdBRiBhbmFseXplcyBldmVyeSByZXF1ZXN0IHRvIHlvdXIgYXBwbGljYXRpb24gdG8gZGV0ZWN0XG4gKiBzdXNwaWNpb3VzIGFjdGl2aXR5LlxuICogT25jZSBhIGNlcnRhaW4gc3VzcGljaW9uIHRocmVzaG9sZCBpcyByZWFjaGVkLFxuICogc3Vic2VxdWVudCByZXF1ZXN0cyBmcm9tIHRoYXQgY2xpZW50IGFyZSBibG9ja2VkIGZvciBhIHBlcmlvZCBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBTaGllbGQgcnVsZS5cbiAqIEByZXR1cm5zXG4gKiAgIFNoaWVsZCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYCBmaWVsZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBzaGllbGQoeyBtb2RlOiBcIkxJVkVcIiB9KTtcbiAqICAgYGBgXG4gKiBAZXhhbXBsZVxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbc2hpZWxkKHsgbW9kZTogXCJMSVZFXCIgfSldLFxuICogICB9KTtcbiAqICAgYGBgXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2hpZWxkL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaGllbGQvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHNoaWVsZChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTaGllbGRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHR5cGUgPSBcIlNISUVMRFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuU2hpZWxkLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2YWxpZGF0ZSgpIHsgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICAvLyBUT0RPKCMxOTg5KTogUHJlZmVyIGNoYXJhY3RlcmlzdGljcyBkZWZpbmVkIG9uIHJ1bGUgb25jZSBhdmFpbGFibGVcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQ2hhcmFjdGVyaXN0aWNzID0gY29udGV4dC5jaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICBjb25zdCBydWxlSWQgPSBhd2FpdCBoYXNoZXIuaGFzaChoYXNoZXIuc3RyaW5nKFwidHlwZVwiLCB0eXBlKSwgaGFzaGVyLnVpbnQzMihcInZlcnNpb25cIiwgdmVyc2lvbiksIGhhc2hlci5zdHJpbmcoXCJtb2RlXCIsIG1vZGUpLCBoYXNoZXIuc3RyaW5nU2xpY2VPcmRlcmVkKFwiY2hhcmFjdGVyaXN0aWNzXCIsIGxvY2FsQ2hhcmFjdGVyaXN0aWNzKSk7XG4gICAgICAgICAgICBjb25zdCBhbmFseXplQ29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IGxvY2FsQ2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgICAgIGxvZzogY29udGV4dC5sb2csXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYW5hbHl6ZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgY29uc3QgW2NhY2hlZCwgdHRsXSA9IGF3YWl0IGNvbnRleHQuY2FjaGUuZ2V0KHJ1bGVJZCwgZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiQ0FDSEVEXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGNhY2hlZC5yZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRTaGllbGRSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICBzaGllbGRUcmlnZ2VyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgc2lnbnVwIGZvcm0gcHJvdGVjdGlvbiBydWxlLlxuICpcbiAqIEFwcGx5aW5nIHRoaXMgcnVsZSBjb21iaW5lcyByYXRlIGxpbWl0aW5nLCBib3QgcHJvdGVjdGlvbiwgYW5kIGVtYWlsXG4gKiB2YWxpZGF0aW9uIHRvIHByb3RlY3QgeW91ciBzaWdudXAgZm9ybXMgZnJvbSBhYnVzZS5cbiAqIFVzaW5nIHRoaXMgcnVsZSB3aWxsIGNvbmZpZ3VyZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gUmF0ZSBsaW1pdGluZyAtIHNpZ251cCBmb3JtcyBhcmUgYSBjb21tb24gdGFyZ2V0IGZvciBib3RzLiBBcmNqZXTigJlzIHJhdGVcbiAqICAgbGltaXRpbmcgaGVscHMgdG8gcHJldmVudCBib3RzIGFuZCBvdGhlciBhdXRvbWF0ZWQgb3IgbWFsaWNpb3VzIGNsaWVudHNcbiAqICAgZnJvbSBzdWJtaXR0aW5nIHlvdXIgc2lnbnVwIGZvcm0gdG9vIG1hbnkgdGltZXMgaW4gYSBzaG9ydCBwZXJpb2Qgb2YgdGltZS5cbiAqIC0gQm90IHByb3RlY3Rpb24gLSBzaWdudXAgZm9ybXMgYXJlIHVzdWFsbHkgZXhjbHVzaXZlbHkgdXNlZCBieSBodW1hbnMsIHdoaWNoXG4gKiAgIG1lYW5zIHRoYXQgYW55IGF1dG9tYXRlZCBzdWJtaXNzaW9ucyB0byB0aGUgZm9ybSBhcmUgbGlrZWx5IHRvIGJlXG4gKiAgIGZyYXVkdWxlbnQuXG4gKiAtIEVtYWlsIHZhbGlkYXRpb24gLSBlbWFpbCBhZGRyZXNzZXMgc2hvdWxkIGJlIHZhbGlkYXRlZCB0byBlbnN1cmUgdGhlIHNpZ251cFxuICogICBpcyBjb21pbmcgZnJvbSBhIGxlZ2l0aW1hdGUgdXNlciB3aXRoIGEgcmVhbCBlbWFpbCBhZGRyZXNzIHRoYXQgY2FuXG4gKiAgIGFjdHVhbGx5IHJlY2VpdmUgbWVzc2FnZXMuXG4gKlxuICogQHRlbXBsYXRlIENoYXJhY3RlcmlzdGljc1xuICogICBDaGFyYWN0ZXJpc3RpY3MgdG8gdHJhY2sgYSB1c2VyIGJ5LlxuICogQHBhcmFtIG9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHNpZ251cCBmb3JtIHByb3RlY3Rpb24gcnVsZS5cbiAqIEByZXR1cm5zXG4gKiAgIFNpZ251cCBmb3JtIHByb3RlY3Rpb24gcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlIGBydWxlc2AgZmllbGQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgT3VyIHJlY29tbWVuZGVkIGNvbmZpZ3VyYXRpb24gZm9yIG1vc3Qgc2lnbnVwIGZvcm1zIGlzOlxuICpcbiAqICAgLSBCbG9jayBlbWFpbCBhZGRyZXNzZXMgd2l0aCBpbnZhbGlkIHN5bnRheCwgdGhhdCBhcmUgZnJvbSBkaXNwb3NhYmxlIGVtYWlsIHByb3ZpZGVycyxcbiAqICAgICBvciBkbyBub3QgaGF2ZSB2YWxpZCBNWCByZWNvcmRzIGNvbmZpZ3VyZWQuXG4gKiAgIC0gQmxvY2sgYWxsIGJvdHMuXG4gKiAgIC0gQXBwbHkgYSByYXRlIGxpbWl0IG9mIDUgc3VibWlzc2lvbnMgcGVyIDEwIG1pbnV0ZXMgZnJvbSBhIHNpbmdsZSBJUFxuICogICAgIGFkZHJlc3MuXG4gKlxuICogICBgYGB0c1xuICogICBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICAgIHJ1bGVzOiBbXG4gKiAgICAgIHByb3RlY3RTaWdudXAoe1xuICogICAgICAgIGVtYWlsOiB7XG4gKiAgICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgIGJsb2NrOiBbXCJESVNQT1NBQkxFXCIsIFwiSU5WQUxJRFwiLCBcIk5PX01YX1JFQ09SRFNcIl0sXG4gKiAgICAgICAgfSxcbiAqICAgICAgICBib3RzOiB7XG4gKiAgICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICAgIGFsbG93OiBbXSwgLy8gYmxvY2sgYWxsIGRldGVjdGVkIGJvdHNcbiAqICAgICAgICB9LFxuICogICAgICAgIHJhdGVMaW1pdDoge1xuICogICAgICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICAgICBpbnRlcnZhbDogXCIxMG1cIixcbiAqICAgICAgICAgIG1heDogNSxcbiAqICAgICAgICB9LFxuICogICAgICB9KSxcbiAqICAgIF0sXG4gKiAgIH0pO1xuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaWdudXAtcHJvdGVjdGlvbi9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2lnbnVwLXByb3RlY3Rpb24vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHByb3RlY3RTaWdudXAob3B0aW9ucykge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLnNsaWRpbmdXaW5kb3cob3B0aW9ucy5yYXRlTGltaXQpLFxuICAgICAgICAuLi5kZXRlY3RCb3Qob3B0aW9ucy5ib3RzKSxcbiAgICAgICAgLi4udmFsaWRhdGVFbWFpbChvcHRpb25zLmVtYWlsKSxcbiAgICBdO1xufVxuLyoqXG4gKiBBcmNqZXQgZmlsdGVyIHJ1bGUuXG4gKlxuICogQXBwbHlpbmcgdGhpcyBydWxlIGxldHMgeW91IGJsb2NrIHJlcXVlc3RzIHVzaW5nIFdpcmVzaGFyay1saWtlIGRpc3BsYXlcbiAqIGZpbHRlciBleHByZXNzaW9ucyBvdmVyIEhUVFAgaGVhZGVycywgSVAgYWRkcmVzc2VzLCBhbmQgb3RoZXIgcmVxdWVzdFxuICogZmllbGRzLlxuICogWW91IGNhbiBxdWlja2x5IGVuZm9yY2UgcnVsZXMgbGlrZSBhbGxvdy9kZW55IGJ5IGNvdW50cnksIG5ldHdvcmssIG9yXG4gKiBgdXNlci1hZ2VudGAgcGF0dGVybi5cbiAqXG4gKiBTZWUgdGhlIFtyZWZlcmVuY2UgZ3VpZGVdKGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2ZpbHRlcnMvcmVmZXJlbmNlKSBmb3JcbiAqIG1vcmUgaW5mbyBvbiB0aGUgZXhwcmVzc2lvbiBsYW5ndWFnZSBmaWVsZHMsIGZ1bmN0aW9ucywgYW5kIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogICBDb25maWd1cmF0aW9uIChyZXF1aXJlZCkuXG4gKiBAcmV0dXJuc1xuICogICBGaWx0ZXIgcnVsZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogICBJbiB0aGlzIGV4YW1wbGUsIHRoZSBleHByZXNzaW9uIG1hdGNoZXMgbm9uLVZQTiBHRVQgcmVxdWVzdHMgZnJvbSB0aGUgVVMuXG4gKiAgIFJlcXVlc3RzIG1hdGNoaW5nIHRoZSBleHByZXNzaW9uIGFyZSBhbGxvd2VkLCBhbGwgb3RoZXJzIGFyZSBkZW5pZWQuXG4gKlxuICogICBgYGB0c1xuICogICBmaWx0ZXIoe1xuICogICAgIGFsbG93OiBbXG4gKiAgICAgICAnaHR0cC5yZXF1ZXN0Lm1ldGhvZCBlcSBcIkdFVFwiIGFuZCBpcC5zcmMuY291bnRyeSBlcSBcIlVTXCIgYW5kIG5vdCBpcC5zcmMudnBuJyxcbiAqICAgICBdLFxuICogICAgIG1vZGU6IFwiTElWRVwiLFxuICogICB9KVxuICogICBgYGBcbiAqXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9maWx0ZXJzL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBmaWx0ZXIob3B0aW9ucykge1xuICAgIHZhbGlkYXRlRmlsdGVyT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93ID8/IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgPz8gW107XG4gICAgaWYgKGFsbG93Lmxlbmd0aCA+IDAgJiYgZGVueS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBmaWx0ZXJgIG9wdGlvbnMgZXJyb3I6IGV4cHJlc3Npb25zIG11c3QgYmUgcGFzc2VkIGluIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBpbnN0ZWFkIG9mIGJvdGhcIik7XG4gICAgfVxuICAgIGlmIChhbGxvdy5sZW5ndGggPT09IDAgJiYgZGVueS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGZpbHRlcmAgb3B0aW9ucyBlcnJvcjogb25lIG9yIG1vcmUgZXhwcmVzc2lvbnMgbXVzdCBiZSBwYXNzZWQgaW4gYGFsbG93YCBvciBgZGVueWBcIik7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gbW9kZSA9PT0gXCJMSVZFXCIgPyBcIlJVTlwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgdHlwZSA9IFwiRklMVEVSXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgcnVsZUlkUHJvbWlzZSA9IGhhc2hlci5oYXNoKGhhc2hlci5zdHJpbmcoXCJ0eXBlXCIsIHR5cGUpLCBoYXNoZXIudWludDMyKFwidmVyc2lvblwiLCB2ZXJzaW9uKSwgaGFzaGVyLnN0cmluZyhcIm1vZGVcIiwgbW9kZSksIGhhc2hlci5zdHJpbmdTbGljZU9yZGVyZWQoXCJhbGxvd1wiLCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBgaGFzaGVyYCBtdXN0IHN1cHBvcnQgcmVhZG9ubHkgdmFsdWVzLlxuICAgIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGhhc2hlcmAgbXVzdCBzdXBwb3J0IHJlYWRvbmx5IHZhbHVlcy5cbiAgICBkZW55KSk7XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgYWxsb3csXG4gICAgICAgIGRlbnksXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5GaWx0ZXIsXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgcnVsZUlkUHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IFtjYWNoZWQsIHR0bF0gPSBhd2FpdCBjb250ZXh0LmNhY2hlLmdldChydWxlSWQsIGNvbnRleHQuZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGNhY2hlZC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludDogY29udGV4dC5maW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBjYWNoZWQucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIkNBQ0hFRFwiLFxuICAgICAgICAgICAgICAgICAgICB0dGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0XyA9IHRvQW5hbHl6ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICBsZXQgcnVsZVJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5tYXRjaEZpbHRlcnMoY29udGV4dCwgcmVxdWVzdF8sIGFsbG93Lmxlbmd0aCA+IDAgPyBhbGxvdyA6IGRlbnksIGFsbG93Lmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgICAgIHJ1bGVSZXN1bHQgPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdC5hbGxvd2VkID8gXCJBTExPV1wiIDogXCJERU5ZXCIsXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50OiBjb250ZXh0LmZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRGaWx0ZXJSZWFzb24ocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiByZXN1bHQuYWxsb3dlZCA/IDAgOiA2MCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJ1bGVSZXN1bHQgPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQ6IGNvbnRleHQuZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKGVycm9yKSxcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVSZXN1bHQ7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHZhbGlkYXRlKCkgeyB9LFxuICAgICAgICB2ZXJzaW9uLFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFyY2pldCBpbnN0YW5jZS5cbiAqXG4gKiBAdGVtcGxhdGUgUnVsZXNcbiAqICAgTGlzdCBvZiBydWxlcy5cbiAqIEB0ZW1wbGF0ZSBDaGFyYWN0ZXJpc3RpY3NcbiAqICAgQ2hhcmFjdGVyaXN0aWNzIHRvIHRyYWNrIGEgdXNlciBieS5cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgIENvbmZpZ3VyYXRpb24uXG4gKiBAcmV0dXJuc1xuICogICBBcmNqZXQgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGFyY2pldChvcHRpb25zKSB7XG4gICAgLy8gV2UgZGVzdHJ1Y3R1cmUgaGVyZSB0byBtYWtlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgbmVhdCB3aGVuIHZpZXdlZCBieSBjb25zdW1lcnNcbiAgICBjb25zdCB7IGtleSwgcnVsZXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgcnQgPSBydW50aW1lKCk7XG4gICAgLy8gVE9ETzogU2VwYXJhdGUgdGhlIEFyY2pldE9wdGlvbnMgZnJvbSB0aGUgU0RLIE9wdGlvbnNcbiAgICAvLyBJdCBpcyBjdXJyZW50bHkgb3B0aW9uYWwgaW4gdGhlIG9wdGlvbnMgc28gdXNlcnMgY2FuIG92ZXJyaWRlIGl0IHZpYSBhbiBTREtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9nID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvZyBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgbG9nID0gb3B0aW9ucy5sb2c7XG4gICAgY29uc3QgcGVyZiA9IG5ldyBQZXJmb3JtYW5jZShsb2cpO1xuICAgIC8vIFRPRE8oIzIwNyk6IFJlbW92ZSB0aGlzIHdoZW4gd2UgY2FuIGRlZmF1bHQgdGhlIHRyYW5zcG9ydCBzbyBjbGllbnQgaXMgbm90IHJlcXVpcmVkXG4gICAgLy8gSXQgaXMgY3VycmVudGx5IG9wdGlvbmFsIGluIHRoZSBvcHRpb25zIHNvIHRoZSBOZXh0IFNESyBjYW4gb3ZlcnJpZGUgaXQgZm9yIHRoZSB1c2VyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsaWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGllbnQgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IG9wdGlvbnMuY2xpZW50O1xuICAgIC8vIEEgbG9jYWwgY2FjaGUgb2YgYmxvY2sgZGVjaXNpb25zLiBNaWdodCBiZSBlbXBoZW1lcmFsIHBlciByZXF1ZXN0LFxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgd2F5IHRoZSBydW50aW1lIHdvcmtzLCBidXQgaXQncyB3b3J0aCBhIHRyeS5cbiAgICAvLyBUT0RPKCMxMzIpOiBTdXBwb3J0IGNvbmZpZ3VyYWJsZSBjYWNoaW5nXG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWVtb3J5Q2FjaGUoKTtcbiAgICBjb25zdCByb290UnVsZXMgPSBydWxlc1xuICAgICAgICAuZmxhdCgxKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHByb3RlY3QocnVsZXMsIGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAvLyBUaGlzIGdvZXMgYWdhaW5zdCB0aGUgdHlwZSBkZWZpbml0aW9uIGFib3ZlLCBidXQgdXNlcnMgbWlnaHQgY2FsbFxuICAgICAgICAvLyBgcHJvdGVjdCgpYCB3aXRoIG5vIHZhbHVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGNyYXNoXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIGlwOiByZXF1ZXN0LmlwLFxuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHByb3RvY29sOiByZXF1ZXN0LnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdDogcmVxdWVzdC5ob3N0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdC5wYXRoLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEFyY2pldEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGNvb2tpZXM6IHJlcXVlc3QuY29va2llcyxcbiAgICAgICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhUHJvcHMocmVxdWVzdCksXG4gICAgICAgICAgICBlbWFpbDogdHlwZW9mIHJlcXVlc3QuZW1haWwgPT09IFwic3RyaW5nXCIgPyByZXF1ZXN0LmVtYWlsIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gb3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NcbiAgICAgICAgICAgID8gWy4uLm9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3Qgd2FpdFVudGlsID0gbG9va3VwV2FpdFVudGlsKCk7XG4gICAgICAgIGNvbnN0IGJhc2VDb250ZXh0ID0ge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbG9nLFxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgd2FpdFVudGlsLFxuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgZmluZ2VycHJpbnQgPSBcIlwiO1xuICAgICAgICBjb25zdCBsb2dGaW5nZXJwcmludFBlcmYgPSBwZXJmLm1lYXN1cmUoXCJmaW5nZXJwcmludFwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmdlcnByaW50ID0gYXdhaXQgYW5hbHl6ZS5nZW5lcmF0ZUZpbmdlcnByaW50KGJhc2VDb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KGRldGFpbHMpKTtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcImZpbmdlcnByaW50ICglcyk6ICVzXCIsIHJ0LCBmaW5nZXJwcmludCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoeyBlcnJvcjogZXJyb3JNZXNzYWdlKGVycm9yKSB9LCBcIkZhaWxlZCB0byBidWlsZCBmaW5nZXJwcmludC4gUGxlYXNlIHZlcmlmeSB5b3VyIENoYXJhY3RlcmlzdGljcy5cIik7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXRFcnJvckRlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oYEZhaWxlZCB0byBidWlsZCBmaW5nZXJwcmludCAtICR7ZXJyb3JNZXNzYWdlKGVycm9yKX1gKSxcbiAgICAgICAgICAgICAgICAvLyBObyByZXN1bHRzIGJlY2F1c2Ugd2UgY291bGRuJ3QgY3JlYXRlIGEgZmluZ2VycHJpbnRcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgc2VuZGluZyB0aGlzIHRvIFJlcG9ydCB3aGVuIHdlIGhhdmUgYW4gaW5mYWxsaWJsZSBmaW5nZXJwcmludFxuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgbG9nRmluZ2VycHJpbnRQZXJmKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgLi4uYmFzZUNvbnRleHQsXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJDYWxsaW5nIGBwcm90ZWN0KClgIHdpdGggbm8gcnVsZXMgaXMgZGVwcmVjYXRlZC4gRGlkIHlvdSBtZWFuIHRvIGNvbmZpZ3VyZSB0aGUgU2hpZWxkIHJ1bGU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGVzLiBPbmx5IDEwIHJ1bGVzIG1heSBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiT25seSAxMCBydWxlcyBtYXkgYmUgc3BlY2lmaWVkXCIpLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB0aGUgc29ydGVkIHJ1bGVzIHdlcmUgdG9vIGxvbmcgYW5kIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAvLyB0byBpbnN0YW50aWF0ZSBhIHRvbiBvZiBOT1RfUlVOIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgXG4gICAgICAgICAgICAvLyBObyBydWxlcyBiZWNhdXNlIHdlJ3ZlIGRldGVybWluZWQgdGhleSB3ZXJlIHRvbyBsb25nIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byB0cnkgdG8gc2VuZCB0aGVtIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHJ1bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYWxsIHJ1bGVzIHRvIE5PVF9SVU4vQUxMT1cgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBlYWNoIFJ1bGUgSUQgYmVmb3JlIHRoZXkgYXJlIHJ1blxuICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSZWFzb24oKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHRvcC1sZXZlbCBjaGFyYWN0ZXJpc3RpY3MgdG8gYWxsIFJhdGUgTGltaXQgcnVsZXMgdGhhdCBkb24ndCBhbHJlYWR5IGhhdmVcbiAgICAgICAgICAgIC8vIHRoZWlyIG93biBzZXQgb2YgY2hhcmFjdGVyaXN0aWNzLlxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlX3J1bGUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGlzUmF0ZUxpbWl0UnVsZShjYW5kaWRhdGVfcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZV9ydWxlLmNoYXJhY3RlcmlzdGljcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVfcnVsZS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2lkeF0gPSBjYW5kaWRhdGVfcnVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nTG9jYWxQZXJmID0gcGVyZi5tZWFzdXJlKFwibG9jYWxcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHJ1bGVdIG9mIHJ1bGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmUtYXNzaWdubWVudCBpcyBhIHdvcmthcm91bmQgdG8gYSBUeXBlU2NyaXB0IGVycm9yIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIHdoZXJlIHRoZSBuYW1lIHdhcyBpbnRyb2R1Y2VkIHZpYSBhIGRlc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxSdWxlID0gcnVsZTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dSdWxlUGVyZiA9IHBlcmYubWVhc3VyZShydWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxSdWxlLnZhbGlkYXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInJ1bGUgbXVzdCBoYXZlIGEgYHZhbGlkYXRlYCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2NhbFJ1bGUudmFsaWRhdGUoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxSdWxlLnByb3RlY3QgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicnVsZSBtdXN0IGhhdmUgYSBgcHJvdGVjdGAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gYXdhaXQgbG9jYWxSdWxlLnByb3RlY3QoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcnVsZSBkaWRuJ3QgcmV0dXJuIGEgcnVsZSByZXN1bHQsIHdlIG5lZWQgdG8gc3R1YiBpdCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAvLyBjcmFzaGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgYSB1c2VyIHdyaXRlcyBhIGN1c3RvbSBsb2NhbFxuICAgICAgICAgICAgICAgICAgICAvLyBydWxlIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdHNbaWR4XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oIzQwMzApOiBJZiB3ZSBjYW4gZ2V0IHRoZSBSdWxlIElEIGJlZm9yZSBydW5uaW5nIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwicnVsZSByZXN1bHQgbWlzc2luZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVzdWx0c1tpZHhdLnJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGV0YWlscy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IHJlc3VsdHNbaWR4XS50dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiByZXN1bHRzW2lkeF0uY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0c1tpZHhdLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJMb2NhbCBydWxlIHJlc3VsdDpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGU6ICVzIGR1ZSB0byAlc1wiLCBydWxlLnR5cGUsIGVycm9yTWVzc2FnZShlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBhIFJ1bGUgSUQgaW4gdGhpcyBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlSWQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIlJVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oZXJyKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBsb2dSdWxlUGVyZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2lkeF07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc0RlbmllZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBydWxlIGlzIG5vdCBhIERSWV9SVU4sIHdlIHdhbnQgdG8gY2FjaGUgbm9uLXplcm8gVFRMIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiBhIERFTlkgZGVjaXNpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgIT09IFwiRFJZX1JVTlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXREZW55RGVjaXNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogcmVzdWx0LnR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhIERFTlkgZGVjaXNpb24gaXMgcmVwb3J0ZWQgdG8gYXZvaWQgY3JlYXRpbmcgMiBlbnRyaWVzIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSByZXF1ZXN0LiBVcG9uIEFMTE9XLCB0aGUgYGRlY2lkZWAgY2FsbCB3aWxsIGNyZWF0ZSBhbiBlbnRyeSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC50dGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQ6IHJlc3VsdC5maW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogcmVzdWx0LmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBcIkNhY2hpbmcgZGVjaXNpb24gZm9yICVkIHNlY29uZHNcIiwgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQocmVzdWx0LnJ1bGVJZCwgcmVzdWx0LmZpbmdlcnByaW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVzdWx0LnR0bCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYERyeSBydW4gbW9kZSBpcyBlbmFibGVkIGZvciBcIiVzXCIgcnVsZS4gT3ZlcnJpZGluZyBkZWNpc2lvbi4gRGVjaXNpb24gd2FzOiBERU5ZYCwgcnVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dMb2NhbFBlcmYoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaXRoIG5vIGNhY2hlZCB2YWx1ZXMsIHdlIHRha2UgYSBkZWNpc2lvbiByZW1vdGVseS4gV2UgdXNlIGEgdGltZW91dCB0b1xuICAgICAgICAvLyBmYWlsIG9wZW4uXG4gICAgICAgIGNvbnN0IGxvZ1JlbW90ZVBlcmYgPSBwZXJmLm1lYXN1cmUoXCJyZW1vdGVcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsb2dEZWRpY2VBcGlQZXJmID0gcGVyZi5tZWFzdXJlKFwiZGVjaWRlQXBpXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBhd2FpdCBjbGllbnRcbiAgICAgICAgICAgICAgICAuZGVjaWRlKGNvbnRleHQsIGRldGFpbHMsIHJ1bGVzKVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBsb2dEZWRpY2VBcGlQZXJmKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZWNpc2lvbiBpcyB0byBibG9jayBhbmQgd2UgaGF2ZSBhIG5vbi16ZXJvIFRUTCwgd2UgY2FjaGUgdGhlXG4gICAgICAgICAgICAvLyBibG9jayBsb2NhbGx5XG4gICAgICAgICAgICBpZiAoZGVjaXNpb24uaXNEZW5pZWQoKSAmJiBkZWNpc2lvbi50dGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiZGVjaWRlOiBDYWNoaW5nIGJsb2NrIGxvY2FsbHkgZm9yICVkIHNlY29uZHNcIiwgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiBkZWNpc2lvbi5yZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIGFsbCBERU5ZIHJlc3VsdHMgZm9yIGxvY2FsIGNhY2hlIGxvb2t1cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5jb25jbHVzaW9uID09PSBcIkRFTllcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuc2V0KHJlc3VsdC5ydWxlSWQsIHJlc3VsdC5maW5nZXJwcmludCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IHJlc3VsdC5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0LnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlc3VsdC50dGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5pbmZvKFwiRW5jb3VudGVyZWQgcHJvYmxlbSBnZXR0aW5nIHJlbW90ZSBkZWNpc2lvbjogJXNcIiwgZXJyb3JNZXNzYWdlKGVycikpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKGVyciksXG4gICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgbG9nUmVtb3RlUGVyZigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5XG4gICAgZnVuY3Rpb24gd2l0aFJ1bGUoYmFzZVJ1bGVzLCBydWxlKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gWy4uLmJhc2VSdWxlcywgLi4ucnVsZV0uc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICB3aXRoUnVsZShydWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhSdWxlKHJ1bGVzLCBydWxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyBwcm90ZWN0KGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90ZWN0KHJ1bGVzLCBjdHgsIHJlcXVlc3QpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF1Z21lbnQgdGhlIGNsaWVudCB3aXRoIGFub3RoZXIgcnVsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIGZvciB2YXJ5aW5nIHJ1bGVzIGJhc2VkIG9uIGNyaXRlcmlhIGluIHlvdXIgaGFuZGxlciBzdWNoIGFzXG4gICAgICAgICAqIGRpZmZlcmVudCByYXRlIGxpbWl0IGZvciBsb2dnZWQgaW4gdXNlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBydWxlXG4gICAgICAgICAqICAgUnVsZSB0byBhZGQgdG8gQXJjamV0LlxuICAgICAgICAgKiBAcmV0dXJuc1xuICAgICAgICAgKiAgIEFyY2pldCBpbnN0YW5jZSBhdWdtZW50ZWQgd2l0aCB0aGUgZ2l2ZW4gcnVsZS5cbiAgICAgICAgICovXG4gICAgICAgIHdpdGhSdWxlKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoUnVsZShyb290UnVsZXMsIHJ1bGUpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZSBhIGRlY2lzaW9uIGFib3V0IGhvdyB0byBoYW5kbGUgYSByZXF1ZXN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYW5hbHl6ZSB0aGUgcmVxdWVzdCBsb2NhbGx5IHdoZXJlIHBvc3NpYmxlIGFuZCBvdGhlcndpc2UgY2FsbFxuICAgICAgICAgKiB0aGUgQXJjamV0IGRlY2lzaW9uIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGN0eFxuICAgICAgICAgKiAgIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhpcyBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdFxuICAgICAgICAgKiAgIERldGFpbHMgYWJvdXQgdGhlIHtAbGlua2NvZGUgQXJjamV0UmVxdWVzdH0gdGhhdCBBcmNqZXQgbmVlZHMgdG8gbWFrZSBhXG4gICAgICAgICAqICAgZGVjaXNpb24uXG4gICAgICAgICAqIEByZXR1cm5zXG4gICAgICAgICAqICAgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIHtAbGlua2NvZGUgQXJjamV0RGVjaXNpb259IGluZGljYXRpbmdcbiAgICAgICAgICogICBBcmNqZXTigJlzIGRlY2lzaW9uIGFib3V0IHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcHJvdGVjdChjdHgsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90ZWN0KHJvb3RSdWxlcywgY3R4LCByZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgYXJjamV0IGFzIGRlZmF1bHQsIGRldGVjdEJvdCwgZmlsdGVyLCBmaXhlZFdpbmRvdywgcHJvdGVjdFNpZ251cCwgc2Vuc2l0aXZlSW5mbywgc2hpZWxkLCBzbGlkaW5nV2luZG93LCB0b2tlbkJ1Y2tldCwgdmFsaWRhdGVFbWFpbCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(middleware)/./node_modules/arcjet/index.js\n");

/***/ })

};
;